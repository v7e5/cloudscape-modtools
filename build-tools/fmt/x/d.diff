diff -r src/components/alert/actions-wrapper/index.jsx ../cloudcomp/lib/components/alert/actions-wrapper/index.jsx
6,20c6,20
< const createActionButton = (
<   testUtilClasses,
<   action,
<   buttonText,
<   onButtonClick
< ) => {
<   if (!action && buttonText) {
<     action = (
<       <InternalButton
<         className={testUtilClasses.actionButton}
<         onClick={onButtonClick}
<         formAction='none'>
<         {buttonText}
<       </InternalButton>
<     )
---
> const createActionButton = memo(
>   (testUtilClasses, action, buttonText, onButtonClick) => {
>     if (!action && buttonText) {
>       action = (
>         <InternalButton
>           className={testUtilClasses.actionButton}
>           onClick={onButtonClick}
>           formAction='none'>
>           {buttonText}
>         </InternalButton>
>       )
>     }
>     return action ? (
>       <div className={testUtilClasses.actionSlot}>{action}</div>
>     ) : null
22,25c22
<   return action ? (
<     <div className={testUtilClasses.actionSlot}>{action}</div>
<   ) : null
< }
---
> )
diff -r src/components/app-layout/classic.jsx ../cloudcomp/lib/components/app-layout/classic.jsx
14d13
< import {applyDefaults} from './defaults'
49c48
<         navigationWidth = 280,
---
>         navigationWidth,
51c50
<         navigationOpen: controlledNavigationOpen,
---
>         navigationOpen,
53c52
<         toolsWidth = 290,
---
>         toolsWidth,
89,103d87
<       const defaults = applyDefaults(
<         contentType,
<         {maxContentWidth, minContentWidth},
<         false
<       )
<       const [navigationOpen = false, setNavigationOpen] = useControllable(
<         controlledNavigationOpen,
<         onNavigationChange,
<         isMobile ? false : defaults.navigationOpen,
<         {
<           componentName: 'AppLayout',
<           controlledProp: 'navigationOpen',
<           changeHandler: 'onNavigationChange'
<         }
<       )
107c91
<         isMobile ? false : defaults.toolsOpen,
---
>         false,
160d143
<         setNavigationOpen(open)
324c307
<           defaults.minContentWidth -
---
>           minContentWidth -
352c335
<         ? {maxWidth: defaults.maxContentWidth}
---
>         ? {maxWidth: maxContentWidth}
407,410c390
<           ? {
<               minWidth: defaults.minContentWidth,
<               maxWidth: defaults.maxContentWidth
<             }
---
>           ? {minWidth: minContentWidth, maxWidth: maxContentWidth}
diff -r src/components/app-layout/defaults.js ../cloudcomp/lib/components/app-layout/defaults.js
44,45c44
<       stateFromProps.navigationOpen ?? contentTypeDefaults.navigationOpen,
<     toolsOpen: stateFromProps.toolsOpen ?? contentTypeDefaults.toolsOpen
---
>       stateFromProps.navigationOpen ?? contentTypeDefaults.navigationOpen
diff -r src/components/app-layout/drawer/index.jsx ../cloudcomp/lib/components/app-layout/drawer/index.jsx
232,265c232,267
<                 {visibleItems.map((item, index) => {
<                   return (
<                     <DrawerTrigger
<                       key={index}
<                       testUtilsClassName={clsx(
<                         testutilStyles['drawers-trigger'],
<                         item.id === TOOLS_DRAWER_ID &&
<                           testutilStyles['tools-toggle']
<                       )}
<                       ariaExpanded={activeDrawerId === item.id}
<                       ref={
<                         item.id === previousActiveDrawerId.current
<                           ? drawerRefs.toggle
<                           : void 0
<                       }
<                       ariaLabel={item.ariaLabels?.triggerButton}
<                       ariaControls={
<                         activeDrawerId === item.id ? item.id : void 0
<                       }
<                       trigger={item.trigger}
<                       badge={item.badge}
<                       itemId={item.id}
<                       isActive={activeDrawerId === item.id}
<                       onClick={
<                         drawers.length !== 1
<                           ? () =>
<                               onDrawerChange(
<                                 item.id !== activeDrawerId ? item.id : null
<                               )
<                           : void 0
<                       }
<                     />
<                   )
<                 })}
---
>                 {visibleItems.map(
>                   memo((item, index) => {
>                     return (
>                       <DrawerTrigger
>                         key={index}
>                         testUtilsClassName={clsx(
>                           testutilStyles['drawers-trigger'],
>                           item.id === TOOLS_DRAWER_ID &&
>                             testutilStyles['tools-toggle']
>                         )}
>                         ariaExpanded={activeDrawerId === item.id}
>                         ref={
>                           item.id === previousActiveDrawerId.current
>                             ? drawerRefs.toggle
>                             : void 0
>                         }
>                         ariaLabel={item.ariaLabels?.triggerButton}
>                         ariaControls={
>                           activeDrawerId === item.id ? item.id : void 0
>                         }
>                         trigger={item.trigger}
>                         badge={item.badge}
>                         itemId={item.id}
>                         isActive={activeDrawerId === item.id}
>                         onClick={
>                           drawers.length !== 1
>                             ? () =>
>                                 onDrawerChange(
>                                   item.id !== activeDrawerId ? item.id : null
>                                 )
>                             : void 0
>                         }
>                       />
>                     )
>                   })
>                 )}
diff -r src/components/app-layout/index.jsx ../cloudcomp/lib/components/app-layout/index.jsx
5a6,9
> import {applyDefaults} from './defaults'
> import {useVisualRefresh} from '../internal/hooks/use-visual-mode'
> import {useControllable} from '../internal/hooks/use-controllable'
> import {useMobile} from '../internal/hooks/use-mobile'
13a18,23
>         navigationWidth = 280,
>         toolsWidth = 290,
>         maxContentWidth,
>         minContentWidth,
>         navigationOpen: controlledNavigationOpen,
>         onNavigationChange: controlledOnNavigationChange,
23c33
<           navigationWidth: rest.navigationWidth,
---
>           navigationWidth,
26,28c36,38
<           toolsWidth: rest.toolsWidth,
<           maxContentWidth: rest.maxContentWidth,
<           minContentWidth: rest.minContentWidth,
---
>           toolsWidth,
>           maxContentWidth,
>           minContentWidth,
32a43,44
>       const isRefresh = useVisualRefresh()
>       const isMobile = useMobile()
63a76,95
>       const {navigationOpen: defaultNavigationOpen, ...restDefaults} =
>         applyDefaults(
>           contentType,
>           {maxContentWidth, minContentWidth},
>           isRefresh
>         )
>       const [navigationOpen = false, setNavigationOpen] = useControllable(
>         controlledNavigationOpen,
>         controlledOnNavigationChange,
>         isMobile ? false : defaultNavigationOpen,
>         {
>           componentName: 'AppLayout',
>           controlledProp: 'navigationOpen',
>           changeHandler: 'onNavigationChange'
>         }
>       )
>       const onNavigationChange = event => {
>         setNavigationOpen(event.detail.open)
>         controlledOnNavigationChange?.(event)
>       }
67a100,104
>         navigationWidth,
>         toolsWidth,
>         navigationOpen,
>         onNavigationChange,
>         ...restDefaults,
diff -r src/components/app-layout/mobile-toolbar/index.jsx ../cloudcomp/lib/components/app-layout/mobile-toolbar/index.jsx
110,118c110,112
<               {visibleItems.map((item, index) => (
<                 <div
<                   className={clsx(
<                     styles['mobile-toggle'],
<                     styles['mobile-toggle-type-drawer']
<                   )}
<                   key={index}
<                   onClick={() => onDrawerChange(item.id)}>
<                   <ToggleButton
---
>               {visibleItems.map(
>                 memo((item, index) => (
>                   <div
120,122c114,115
<                       testutilStyles['drawers-trigger'],
<                       item.id === TOOLS_DRAWER_ID &&
<                         testutilStyles['tools-toggle']
---
>                       styles['mobile-toggle'],
>                       styles['mobile-toggle-type-drawer']
124,132c117,134
<                     iconName={item.trigger.iconName}
<                     iconSvg={item.trigger.iconSvg}
<                     badge={item.badge}
<                     ariaLabel={item.ariaLabels?.triggerButton}
<                     ariaExpanded={activeDrawerId === item.id}
<                     testId={`awsui-app-layout-trigger-${item.id}`}
<                   />
<                 </div>
<               ))}
---
>                     key={index}
>                     onClick={() => onDrawerChange(item.id)}>
>                     <ToggleButton
>                       className={clsx(
>                         testutilStyles['drawers-trigger'],
>                         item.id === TOOLS_DRAWER_ID &&
>                           testutilStyles['tools-toggle']
>                       )}
>                       iconName={item.trigger.iconName}
>                       iconSvg={item.trigger.iconSvg}
>                       badge={item.badge}
>                       ariaLabel={item.ariaLabels?.triggerButton}
>                       ariaExpanded={activeDrawerId === item.id}
>                       testId={`awsui-app-layout-trigger-${item.id}`}
>                     />
>                   </div>
>                 ))
>               )}
diff -r src/components/app-layout/runtime-api.jsx ../cloudcomp/lib/components/app-layout/runtime-api.jsx
0a1
> import {memo} from 'react'
5c6
< const convertRuntimeDrawers = drawers => {
---
> const convertRuntimeDrawers = memo(drawers => {
7c8
<     ({mountContent, unmountContent, trigger, ...runtimeDrawer}) => ({
---
>     memo(({mountContent, unmountContent, trigger, ...runtimeDrawer}) => ({
29c30
<     })
---
>     }))
36c37
< }
---
> })
diff -r src/components/app-layout/utils/use-resize.jsx ../cloudcomp/lib/components/app-layout/utils/use-resize.jsx
1c1
< import {useState, useEffect} from 'react'
---
> import {useState, useEffect, memo} from 'react'
11,41c11,21
< const useResize = (
<   drawerRefObject,
<   {
<     activeDrawer,
<     activeDrawerSize,
<     onActiveDrawerResize,
<     drawersRefs,
<     isToolsOpen,
<     drawersMaxWidth
<   }
< ) => {
<   const toolsWidth = 290
<   const MIN_WIDTH = Math.min(
<     activeDrawer?.defaultSize ?? Number.POSITIVE_INFINITY,
<     toolsWidth
<   )
<   const [relativeSize, setRelativeSize] = useState(0)
<   const drawerSize = !activeDrawer && !isToolsOpen ? 0 : activeDrawerSize
<   useEffect(() => {
<     const handle = requestAnimationFrame(() => {
<       const maxSize = drawersMaxWidth
<       setRelativeSize(((drawerSize - MIN_WIDTH) / (maxSize - MIN_WIDTH)) * 100)
<     })
<     return () => cancelAnimationFrame(handle)
<   }, [drawerSize, drawersMaxWidth, MIN_WIDTH])
<   const setSidePanelWidth = width => {
<     const maxWidth = drawersMaxWidth
<     const size = getLimitedValue(MIN_WIDTH, width, maxWidth)
<     const id = activeDrawer?.id
<     if (id && maxWidth >= MIN_WIDTH) {
<       onActiveDrawerResize({size, id})
---
> const useResize = memo(
>   (
>     drawerRefObject,
>     {
>       activeDrawer,
>       activeDrawerSize,
>       onActiveDrawerResize,
>       drawersRefs,
>       isToolsOpen,
>       drawersMinWidth,
>       drawersMaxWidth
43,69c23,60
<   }
<   const sizeControlProps = {
<     position: 'side',
<     panelRef: drawerRefObject,
<     handleRef: drawersRefs.slider,
<     onResize: setSidePanelWidth,
<     hasTransitions: true
<   }
<   const onSliderPointerDown = usePointerEvents(sizeControlProps)
<   const onKeyDown = useKeyboardEvents(sizeControlProps)
<   const resizeHandle = (
<     <div
<       ref={drawersRefs.slider}
<       role='slider'
<       tabIndex={0}
<       aria-label={activeDrawer?.ariaLabels?.resizeHandle}
<       aria-valuemax={100}
<       aria-valuemin={0}
<       aria-valuenow={relativeSize}
<       className={clsx(
<         splitPanelStyles.slider,
<         splitPanelStyles[`slider-side`],
<         testutilStyles['drawers-slider']
<       )}
<       onKeyDown={onKeyDown}
<       onPointerDown={onSliderPointerDown}>
<       <ResizeHandler
---
>   ) => {
>     const [relativeSize, setRelativeSize] = useState(0)
>     const drawerSize = !activeDrawer && !isToolsOpen ? 0 : activeDrawerSize
>     useEffect(() => {
>       const handle = requestAnimationFrame(() => {
>         const maxSize = drawersMaxWidth
>         setRelativeSize(
>           ((drawerSize - drawersMinWidth) / (maxSize - drawersMinWidth)) * 100
>         )
>       })
>       return () => cancelAnimationFrame(handle)
>     }, [drawerSize, drawersMaxWidth, drawersMinWidth])
>     const setSidePanelWidth = width => {
>       const maxWidth = drawersMaxWidth
>       const size = getLimitedValue(drawersMinWidth, width, maxWidth)
>       const id = activeDrawer?.id
>       if (id && maxWidth >= drawersMinWidth) {
>         onActiveDrawerResize({size, id})
>       }
>     }
>     const sizeControlProps = {
>       position: 'side',
>       panelRef: drawerRefObject,
>       handleRef: drawersRefs.slider,
>       onResize: setSidePanelWidth,
>       hasTransitions: true
>     }
>     const onSliderPointerDown = usePointerEvents(sizeControlProps)
>     const onKeyDown = useKeyboardEvents(sizeControlProps)
>     const resizeHandle = (
>       <div
>         ref={drawersRefs.slider}
>         role='slider'
>         tabIndex={0}
>         aria-label={activeDrawer?.ariaLabels?.resizeHandle}
>         aria-valuemax={100}
>         aria-valuemin={0}
>         aria-valuenow={relativeSize}
71,72c62,64
<           splitPanelStyles['slider-icon'],
<           splitPanelStyles[`slider-icon-side`]
---
>           splitPanelStyles.slider,
>           splitPanelStyles[`slider-side`],
>           testutilStyles['drawers-slider']
74,81c66,81
<       />
<     </div>
<   )
<   return {
<     resizeHandle: (
<       <div className={styles['drawer-slider']}>{resizeHandle}</div>
<     ),
<     drawerSize
---
>         onKeyDown={onKeyDown}
>         onPointerDown={onSliderPointerDown}>
>         <ResizeHandler
>           className={clsx(
>             splitPanelStyles['slider-icon'],
>             splitPanelStyles[`slider-icon-side`]
>           )}
>         />
>       </div>
>     )
>     return {
>       resizeHandle: (
>         <div className={styles['drawer-slider']}>{resizeHandle}</div>
>       ),
>       drawerSize
>     }
83c83
< }
---
> )
diff -r src/components/app-layout/visual-refresh/context.jsx ../cloudcomp/lib/components/app-layout/visual-refresh/context.jsx
12d11
< import {applyDefaults} from '../defaults'
29a29
> import {SPLIT_PANEL_MIN_WIDTH} from '../split-panel'
42,86c42,67
<   forwardRef(
<     (
<       {
<         toolsHide,
<         toolsOpen: controlledToolsOpen,
<         navigationHide,
<         navigationOpen: controlledNavigationOpen,
<         contentType,
<         headerSelector,
<         footerSelector,
<         children,
<         splitPanel,
<         ...props
<       },
<       forwardRef
<     ) => {
<       const isMobile = useMobile()
<       const __embeddedViewMode = Boolean(props.__embeddedViewMode)
<       const [hasStickyBackground, setHasStickyBackground] = useState(false)
<       const geckoMaxCssLength = ((1 << 30) - 1) / 60
<       const halfGeckoMaxCssLength = geckoMaxCssLength / 2
<       const maxContentWidth =
<         props.maxContentWidth && props.maxContentWidth > halfGeckoMaxCssLength
<           ? halfGeckoMaxCssLength
<           : props.maxContentWidth ?? 0
<       const minContentWidth = props.minContentWidth ?? 280
<       const contentTypeDefaults = applyDefaults(
<         contentType,
<         {maxContentWidth, minContentWidth},
<         true
<       )
<       const [isNavigationOpen = false, setIsNavigationOpen] = useControllable(
<         controlledNavigationOpen,
<         props.onNavigationChange,
<         isMobile ? false : contentTypeDefaults.navigationOpen,
<         {
<           componentName: 'AppLayout',
<           controlledProp: 'navigationOpen',
<           changeHandler: 'onNavigationChange'
<         }
<       )
<       const {refs: navigationRefs, setFocus: focusNavButtons} =
<         useFocusControl(isNavigationOpen)
<       const handleNavigationClick = useStableCallback(isOpen => {
<         setIsNavigationOpen(isOpen)
---
>   forwardRef((props, forwardRef) => {
>     const {
>       toolsHide,
>       toolsOpen: controlledToolsOpen,
>       navigationHide,
>       navigationOpen,
>       contentType,
>       headerSelector,
>       footerSelector,
>       children,
>       splitPanel
>     } = props
>     const isMobile = useMobile()
>     const __embeddedViewMode = Boolean(props.__embeddedViewMode)
>     const [hasStickyBackground, setHasStickyBackground] = useState(false)
>     const geckoMaxCssLength = ((1 << 30) - 1) / 60
>     const halfGeckoMaxCssLength = geckoMaxCssLength / 2
>     const maxContentWidth =
>       props.maxContentWidth && props.maxContentWidth > halfGeckoMaxCssLength
>         ? halfGeckoMaxCssLength
>         : props.maxContentWidth ?? 0
>     const minContentWidth = props.minContentWidth ?? 280
>     const {refs: navigationRefs, setFocus: focusNavButtons} =
>       useFocusControl(navigationOpen)
>     const handleNavigationClick = useStableCallback(
>       function handleNavigationChange(isOpen) {
89,150c70,131
<       })
<       useEffect(() => {
<         if (isMobile) {
<           handleNavigationClick(false)
<         }
<       }, [isMobile, handleNavigationClick])
<       const toolsWidth = props.toolsWidth ?? 290
<       const hasDefaultToolsWidth = props.toolsWidth === void 0
<       const [isToolsOpen = false, setIsToolsOpen] = useControllable(
<         controlledToolsOpen,
<         props.onToolsChange,
<         isMobile ? false : contentTypeDefaults.toolsOpen,
<         {
<           componentName: 'AppLayout',
<           controlledProp: 'toolsOpen',
<           changeHandler: 'onToolsChange'
<         }
<       )
<       const {
<         refs: toolsRefs,
<         setFocus: focusToolsButtons,
<         loseFocus: loseToolsFocus
<       } = useFocusControl(isToolsOpen, true)
<       const handleToolsClick = useCallback(
<         (isOpen, skipFocusControl) => {
<           setIsToolsOpen(isOpen)
<           !skipFocusControl && focusToolsButtons()
<           fireNonCancelableEvent(props.onToolsChange, {open: isOpen})
<         },
<         [props.onToolsChange, setIsToolsOpen, focusToolsButtons]
<       )
<       const headerHeight = useObservedElement(headerSelector)
<       const footerHeight = useObservedElement(footerSelector)
<       const splitPanelMinWidth = 280
<       const [splitPanelMaxWidth, setSplitPanelMaxWidth] =
<         useState(splitPanelMinWidth)
<       const [isSplitPanelOpen, setIsSplitPanelOpen] = useControllable(
<         props.splitPanelOpen,
<         props.onSplitPanelToggle,
<         false,
<         {
<           componentName: 'AppLayout',
<           controlledProp: 'splitPanelOpen',
<           changeHandler: 'onSplitPanelToggle'
<         }
<       )
<       const [splitPanelPreferences, setSplitPanelPreferences] =
<         useControllable(
<           props.splitPanelPreferences,
<           props.onSplitPanelPreferencesChange,
<           void 0,
<           {
<             componentName: 'AppLayout',
<             controlledProp: 'splitPanelPreferences',
<             changeHandler: 'onSplitPanelPreferencesChange'
<           }
<         )
<       const {
<         refs: splitPanelRefs,
<         setLastInteraction: setSplitPanelLastInteraction
<       } = useSplitPanelFocusControl([splitPanelPreferences, isSplitPanelOpen])
<       const handleSplitPanelClick = useCallback(() => {
---
>       }
>     )
>     useEffect(() => {
>       if (isMobile) {
>         handleNavigationClick(false)
>       }
>     }, [isMobile, handleNavigationClick])
>     const toolsWidth = props.toolsWidth
>     const [isToolsOpen = false, setIsToolsOpen] = useControllable(
>       controlledToolsOpen,
>       props.onToolsChange,
>       false,
>       {
>         componentName: 'AppLayout',
>         controlledProp: 'toolsOpen',
>         changeHandler: 'onToolsChange'
>       }
>     )
>     const {
>       refs: toolsRefs,
>       setFocus: focusToolsButtons,
>       loseFocus: loseToolsFocus
>     } = useFocusControl(isToolsOpen, true)
>     const handleToolsClick = useCallback(
>       function handleToolsChange(isOpen, skipFocusControl) {
>         setIsToolsOpen(isOpen)
>         !skipFocusControl && focusToolsButtons()
>         fireNonCancelableEvent(props.onToolsChange, {open: isOpen})
>       },
>       [props.onToolsChange, setIsToolsOpen, focusToolsButtons]
>     )
>     const headerHeight = useObservedElement(headerSelector)
>     const footerHeight = useObservedElement(footerSelector)
>     const [splitPanelMaxWidth, setSplitPanelMaxWidth] = useState(
>       SPLIT_PANEL_MIN_WIDTH
>     )
>     const [isSplitPanelOpen, setIsSplitPanelOpen] = useControllable(
>       props.splitPanelOpen,
>       props.onSplitPanelToggle,
>       false,
>       {
>         componentName: 'AppLayout',
>         controlledProp: 'splitPanelOpen',
>         changeHandler: 'onSplitPanelToggle'
>       }
>     )
>     const [splitPanelPreferences, setSplitPanelPreferences] = useControllable(
>       props.splitPanelPreferences,
>       props.onSplitPanelPreferencesChange,
>       void 0,
>       {
>         componentName: 'AppLayout',
>         controlledProp: 'splitPanelPreferences',
>         changeHandler: 'onSplitPanelPreferencesChange'
>       }
>     )
>     const {
>       refs: splitPanelRefs,
>       setLastInteraction: setSplitPanelLastInteraction
>     } = useSplitPanelFocusControl([splitPanelPreferences, isSplitPanelOpen])
>     const handleSplitPanelClick = useCallback(
>       function handleSplitPanelChange() {
158c139,140
<       }, [
---
>       },
>       [
163,255c145,177
<       ])
<       const [isSplitPanelForcedPosition, setSplitPanelForcedPosition] =
<         useState(false)
<       const splitPanelPosition = getSplitPanelPosition(
<         isSplitPanelForcedPosition,
<         splitPanelPreferences
<       )
<       useEffect(() => {
<         setSplitPanelForcedPosition(splitPanelMinWidth > splitPanelMaxWidth)
<       }, [splitPanelMaxWidth, splitPanelMinWidth])
<       const [splitPanelReportedSize, setSplitPanelReportedSize] = useState(0)
<       const [
<         splitPanelReportedHeaderHeight,
<         setSplitPanelReportedHeaderHeight
<       ] = useState(0)
<       const [splitPanelToggle, setSplitPanelToggle] = useState({
<         displayed: false,
<         ariaLabel: void 0
<       })
<       const splitPanelDisplayed =
<         !!(splitPanelToggle.displayed || isSplitPanelOpen) && !!splitPanel
<       const splitPanelControlId = useUniqueId('split-panel-')
<       const toolsControlId = useUniqueId('tools-')
<       const [splitPanelSize, setSplitPanelSize] = useControllable(
<         props.splitPanelSize,
<         props.onSplitPanelResize,
<         getSplitPanelDefaultSize(splitPanelPosition),
<         {
<           componentName: 'AppLayout',
<           controlledProp: 'splitPanelSize',
<           changeHandler: 'onSplitPanelResize'
<         }
<       )
<       const handleSplitPanelResize = useCallback(
<         size => {
<           setSplitPanelSize(size)
<           fireNonCancelableEvent(props.onSplitPanelResize, {size})
<         },
<         [props.onSplitPanelResize, setSplitPanelSize]
<       )
<       const handleSplitPanelPreferencesChange = useCallback(
<         detail => {
<           setSplitPanelPreferences(detail)
<           setSplitPanelLastInteraction({type: 'position'})
<           fireNonCancelableEvent(props.onSplitPanelPreferencesChange, detail)
<         },
<         [
<           props.onSplitPanelPreferencesChange,
<           setSplitPanelPreferences,
<           setSplitPanelLastInteraction
<         ]
<       )
<       const {
<         drawers,
<         activeDrawer,
<         activeDrawerId,
<         minDrawerSize: drawersMinWidth,
<         onActiveDrawerChange,
<         onActiveDrawerResize,
<         activeDrawerSize,
<         ...drawersProps
<       } = useDrawers(props, props.ariaLabels, {
<         ariaLabels: props.ariaLabels,
<         toolsHide,
<         toolsOpen: isToolsOpen,
<         tools: props.tools,
<         toolsWidth,
<         onToolsToggle: handleToolsClick
<       })
<       const [drawersMaxWidth, setDrawersMaxWidth] = useState(toolsWidth)
<       const hasDrawers = !!drawers && drawers.length > 0
<       const {
<         refs: drawersRefs,
<         setFocus: focusDrawersButtons,
<         loseFocus: loseDrawersFocus
<       } = useFocusControl(!!activeDrawerId, true, activeDrawerId)
<       const drawerRef = useRef(null)
<       const {resizeHandle, drawerSize} = useResize(drawerRef, {
<         onActiveDrawerResize,
<         activeDrawerSize,
<         activeDrawer,
<         drawersRefs,
<         isToolsOpen,
<         drawersMaxWidth
<       })
<       const handleDrawersClick = (id, skipFocusControl) => {
<         const newActiveDrawerId = id !== activeDrawerId ? id : null
<         onActiveDrawerChange(newActiveDrawerId)
<         !skipFocusControl && focusDrawersButtons()
<       }
<       let drawersTriggerCount = drawers ? drawers.length : !toolsHide ? 1 : 0
<       if (splitPanelDisplayed && splitPanelPosition === 'side') {
<         drawersTriggerCount++
---
>       ]
>     )
>     const [isSplitPanelForcedPosition, setSplitPanelForcedPosition] =
>       useState(false)
>     const splitPanelPosition = getSplitPanelPosition(
>       isSplitPanelForcedPosition,
>       splitPanelPreferences
>     )
>     useEffect(
>       function handleSplitPanelForcePosition() {
>         setSplitPanelForcedPosition(SPLIT_PANEL_MIN_WIDTH > splitPanelMaxWidth)
>       },
>       [splitPanelMaxWidth]
>     )
>     const [splitPanelReportedSize, setSplitPanelReportedSize] = useState(0)
>     const [splitPanelReportedHeaderHeight, setSplitPanelReportedHeaderHeight] =
>       useState(0)
>     const [splitPanelToggle, setSplitPanelToggle] = useState({
>       displayed: false,
>       ariaLabel: void 0
>     })
>     const splitPanelDisplayed =
>       !!(splitPanelToggle.displayed || isSplitPanelOpen) && !!splitPanel
>     const splitPanelControlId = useUniqueId('split-panel-')
>     const toolsControlId = useUniqueId('tools-')
>     const [splitPanelSize, setSplitPanelSize] = useControllable(
>       props.splitPanelSize,
>       props.onSplitPanelResize,
>       getSplitPanelDefaultSize(splitPanelPosition),
>       {
>         componentName: 'AppLayout',
>         controlledProp: 'splitPanelSize',
>         changeHandler: 'onSplitPanelResize'
257,280c179,266
<       const hasOpenDrawer =
<         !!activeDrawerId ||
<         (!toolsHide && isToolsOpen) ||
<         (splitPanelDisplayed &&
<           splitPanelPosition === 'side' &&
<           isSplitPanelOpen)
<       const hasDrawerViewportOverlay =
<         isMobile &&
<         (!!activeDrawerId ||
<           (!navigationHide && isNavigationOpen) ||
<           (!toolsHide && isToolsOpen))
<       const [layoutContainerQuery, layoutElement] = useContainerQuery(
<         rect => rect.contentBoxWidth
<       )
<       const layoutWidth = layoutContainerQuery ?? 0
<       const mainElement = useRef(null)
<       const [mainOffsetLeft, setMainOffsetLeft] = useState(0)
<       const {hasBackgroundOverlap, updateBackgroundOverlapHeight} =
<         useBackgroundOverlap({
<           contentHeader: props.contentHeader,
<           disableContentHeaderOverlap: props.disableContentHeaderOverlap,
<           layoutElement
<         })
<       useEffect(() => {
---
>     )
>     const handleSplitPanelResize = useCallback(
>       size => {
>         setSplitPanelSize(size)
>         fireNonCancelableEvent(props.onSplitPanelResize, {size})
>       },
>       [props.onSplitPanelResize, setSplitPanelSize]
>     )
>     const handleSplitPanelPreferencesChange = useCallback(
>       function handleSplitPanelChange(detail) {
>         setSplitPanelPreferences(detail)
>         setSplitPanelLastInteraction({type: 'position'})
>         fireNonCancelableEvent(props.onSplitPanelPreferencesChange, detail)
>       },
>       [
>         props.onSplitPanelPreferencesChange,
>         setSplitPanelPreferences,
>         setSplitPanelLastInteraction
>       ]
>     )
>     const {
>       drawers,
>       activeDrawer,
>       activeDrawerId,
>       minDrawerSize: drawersMinWidth,
>       onActiveDrawerChange,
>       onActiveDrawerResize,
>       activeDrawerSize,
>       ...drawersProps
>     } = useDrawers(props, props.ariaLabels, {
>       ariaLabels: props.ariaLabels,
>       toolsHide,
>       toolsOpen: isToolsOpen,
>       tools: props.tools,
>       toolsWidth,
>       onToolsToggle: handleToolsClick
>     })
>     const [drawersMaxWidth, setDrawersMaxWidth] = useState(toolsWidth)
>     const hasDrawers = !!drawers && drawers.length > 0
>     const {
>       refs: drawersRefs,
>       setFocus: focusDrawersButtons,
>       loseFocus: loseDrawersFocus
>     } = useFocusControl(!!activeDrawerId, true, activeDrawerId)
>     const drawerRef = useRef(null)
>     const {resizeHandle, drawerSize} = useResize(drawerRef, {
>       onActiveDrawerResize,
>       activeDrawerSize,
>       activeDrawer,
>       drawersRefs,
>       isToolsOpen,
>       drawersMaxWidth,
>       drawersMinWidth
>     })
>     const handleDrawersClick = (id, skipFocusControl) => {
>       const newActiveDrawerId = id !== activeDrawerId ? id : null
>       onActiveDrawerChange(newActiveDrawerId)
>       !skipFocusControl && focusDrawersButtons()
>     }
>     let drawersTriggerCount = drawers ? drawers.length : !toolsHide ? 1 : 0
>     if (splitPanelDisplayed && splitPanelPosition === 'side') {
>       drawersTriggerCount++
>     }
>     const hasOpenDrawer =
>       !!activeDrawerId ||
>       (!toolsHide && isToolsOpen) ||
>       (splitPanelDisplayed &&
>         splitPanelPosition === 'side' &&
>         isSplitPanelOpen)
>     const hasDrawerViewportOverlay =
>       isMobile &&
>       (!!activeDrawerId ||
>         (!navigationHide && navigationOpen) ||
>         (!toolsHide && isToolsOpen))
>     const [layoutContainerQuery, layoutElement] = useContainerQuery(
>       rect => rect.contentBoxWidth
>     )
>     const layoutWidth = layoutContainerQuery ?? 0
>     const mainElement = useRef(null)
>     const [mainOffsetLeft, setMainOffsetLeft] = useState(0)
>     const {hasBackgroundOverlap, updateBackgroundOverlapHeight} =
>       useBackgroundOverlap({
>         contentHeader: props.contentHeader,
>         disableContentHeaderOverlap: props.disableContentHeaderOverlap,
>         layoutElement
>       })
>     useEffect(
>       function handleMainOffsetLeft() {
282,284c268,273
<       }, [layoutWidth, isNavigationOpen, isToolsOpen, splitPanelReportedSize])
<       useEffect(() => {
<         if (isMobile && (isNavigationOpen || isToolsOpen || !!activeDrawer)) {
---
>       },
>       [layoutWidth, navigationOpen, isToolsOpen, splitPanelReportedSize]
>     )
>     useEffect(
>       function handleBodyScroll() {
>         if (isMobile && (navigationOpen || isToolsOpen || !!activeDrawer)) {
289c278
<         return () => {
---
>         return function cleanup() {
292,303c281,293
<       }, [isMobile, isNavigationOpen, isToolsOpen, activeDrawer])
<       const [notificationsContainerQuery, notificationsElement] =
<         useContainerQuery(rect => rect.contentBoxHeight)
<       const notificationsHeight = notificationsContainerQuery ?? 0
<       const hasNotificationsContent = notificationsHeight > 0
<       let offsetBottom = footerHeight
<       if (splitPanelDisplayed && splitPanelPosition === 'bottom') {
<         if (isSplitPanelOpen) {
<           offsetBottom += splitPanelReportedSize
<         } else {
<           offsetBottom += splitPanelReportedHeaderHeight
<         }
---
>       },
>       [isMobile, navigationOpen, isToolsOpen, activeDrawer]
>     )
>     const [notificationsContainerQuery, notificationsElement] =
>       useContainerQuery(rect => rect.contentBoxHeight)
>     const notificationsHeight = notificationsContainerQuery ?? 0
>     const hasNotificationsContent = notificationsHeight > 0
>     let offsetBottom = footerHeight
>     if (splitPanelDisplayed && splitPanelPosition === 'bottom') {
>       if (isSplitPanelOpen) {
>         offsetBottom += splitPanelReportedSize
>       } else {
>         offsetBottom += splitPanelReportedHeaderHeight
305c295,297
<       useEffect(() => {
---
>     }
>     useEffect(
>       function handleSplitPanelMaxWidth() {
329c321,322
<       }, [
---
>       },
>       [
333c326
<         isNavigationOpen,
---
>         navigationOpen,
339,362c332,387
<       ])
<       useImperativeHandle(
<         forwardRef,
<         () => {
<           return {
<             closeNavigationIfNecessary: () => {
<               isMobile && handleNavigationClick(false)
<             },
<             openTools: () => {
<               handleToolsClick(true)
<             },
<             focusToolsClose: () => {
<               if (hasDrawers) {
<                 focusDrawersButtons(true)
<               } else {
<                 focusToolsButtons(true)
<               }
<             },
<             focusActiveDrawer: () => focusDrawersButtons(true),
<             focusSplitPanel: () => splitPanelRefs.slider.current?.focus()
<           }
<         },
<         [
<           isMobile,
---
>       ]
>     )
>     useImperativeHandle(
>       forwardRef,
>       function createImperativeHandle() {
>         return {
>           closeNavigationIfNecessary: () => {
>             isMobile && handleNavigationClick(false)
>           },
>           openTools: () => {
>             handleToolsClick(true)
>           },
>           focusToolsClose: () => {
>             if (hasDrawers) {
>               focusDrawersButtons(true)
>             } else {
>               focusToolsButtons(true)
>             }
>           },
>           focusActiveDrawer: () => focusDrawersButtons(true),
>           focusSplitPanel: () => splitPanelRefs.slider.current?.focus()
>         }
>       },
>       [
>         isMobile,
>         handleNavigationClick,
>         handleToolsClick,
>         focusToolsButtons,
>         focusDrawersButtons,
>         splitPanelRefs.slider,
>         hasDrawers
>       ]
>     )
>     return (
>       <AppLayoutInternalsContext.Provider
>         value={{
>           ...props,
>           activeDrawerId,
>           contentType,
>           drawers,
>           drawersAriaLabel: drawersProps.ariaLabelsWithDrawers?.drawers,
>           drawersOverflowAriaLabel:
>             drawersProps.ariaLabelsWithDrawers?.drawersOverflow,
>           drawersOverflowWithBadgeAriaLabel:
>             drawersProps.ariaLabelsWithDrawers?.drawersOverflowWithBadge,
>           drawersRefs,
>           drawersMinWidth,
>           drawersMaxWidth,
>           drawerSize,
>           drawerRef,
>           resizeHandle,
>           drawersTriggerCount,
>           headerHeight,
>           footerHeight,
>           hasDrawerViewportOverlay,
>           handleDrawersClick,
363a389,391
>           handleSplitPanelClick,
>           handleSplitPanelPreferencesChange,
>           handleSplitPanelResize,
365,372c393,438
<           focusToolsButtons,
<           focusDrawersButtons,
<           splitPanelRefs.slider,
<           hasDrawers
<         ]
<       )
<       return (
<         <AppLayoutInternalsContext.Provider
---
>           hasBackgroundOverlap,
>           hasNotificationsContent,
>           hasOpenDrawer,
>           hasStickyBackground,
>           isBackgroundOverlapDisabled:
>             props.disableContentHeaderOverlap || !hasBackgroundOverlap,
>           isMobile,
>           isSplitPanelForcedPosition,
>           isSplitPanelOpen,
>           isToolsOpen,
>           layoutElement,
>           layoutWidth,
>           loseToolsFocus,
>           loseDrawersFocus,
>           mainElement,
>           mainOffsetLeft,
>           maxContentWidth,
>           minContentWidth,
>           navigationHide,
>           navigationRefs,
>           notificationsElement,
>           notificationsHeight,
>           offsetBottom,
>           setHasStickyBackground,
>           setSplitPanelReportedSize,
>           setSplitPanelReportedHeaderHeight,
>           splitPanel,
>           splitPanelControlId,
>           splitPanelDisplayed,
>           splitPanelMaxWidth,
>           splitPanelPosition,
>           splitPanelPreferences,
>           splitPanelReportedSize,
>           splitPanelReportedHeaderHeight,
>           splitPanelSize,
>           splitPanelToggle,
>           setSplitPanelToggle,
>           splitPanelRefs,
>           toolsControlId,
>           toolsHide,
>           toolsOpen: isToolsOpen,
>           toolsWidth,
>           toolsRefs,
>           __embeddedViewMode
>         }}>
>         <AppLayoutContext.Provider
374,450c440,441
<             ...props,
<             activeDrawerId,
<             contentType,
<             drawers,
<             drawersAriaLabel: drawersProps.ariaLabelsWithDrawers?.drawers,
<             drawersOverflowAriaLabel:
<               drawersProps.ariaLabelsWithDrawers?.drawersOverflow,
<             drawersOverflowWithBadgeAriaLabel:
<               drawersProps.ariaLabelsWithDrawers?.drawersOverflowWithBadge,
<             drawersRefs,
<             drawersMinWidth,
<             drawersMaxWidth,
<             drawerSize,
<             drawerRef,
<             resizeHandle,
<             drawersTriggerCount,
<             headerHeight,
<             footerHeight,
<             hasDefaultToolsWidth,
<             hasDrawerViewportOverlay,
<             handleDrawersClick,
<             handleNavigationClick,
<             handleSplitPanelClick,
<             handleSplitPanelPreferencesChange,
<             handleSplitPanelResize,
<             handleToolsClick,
<             hasBackgroundOverlap,
<             hasNotificationsContent,
<             hasOpenDrawer,
<             hasStickyBackground,
<             isBackgroundOverlapDisabled:
<               props.disableContentHeaderOverlap || !hasBackgroundOverlap,
<             isMobile,
<             isNavigationOpen: isNavigationOpen ?? false,
<             isSplitPanelForcedPosition,
<             isSplitPanelOpen,
<             isToolsOpen,
<             layoutElement,
<             layoutWidth,
<             loseToolsFocus,
<             loseDrawersFocus,
<             mainElement,
<             mainOffsetLeft,
<             maxContentWidth,
<             minContentWidth,
<             navigationHide,
<             navigationRefs,
<             notificationsElement,
<             notificationsHeight,
<             offsetBottom,
<             setHasStickyBackground,
<             setSplitPanelReportedSize,
<             setSplitPanelReportedHeaderHeight,
<             splitPanel,
<             splitPanelControlId,
<             splitPanelDisplayed,
<             splitPanelMaxWidth,
<             splitPanelMinWidth,
<             splitPanelPosition,
<             splitPanelPreferences,
<             splitPanelReportedSize,
<             splitPanelReportedHeaderHeight,
<             splitPanelSize,
<             splitPanelToggle,
<             setSplitPanelToggle,
<             splitPanelRefs,
<             toolsControlId,
<             toolsHide,
<             toolsOpen: isToolsOpen,
<             toolsWidth,
<             toolsRefs,
<             __embeddedViewMode
<           }}>
<           <AppLayoutContext.Provider
<             value={{
<               stickyOffsetBottom: offsetBottom,
<               stickyOffsetTop: 0,
---
>             stickyOffsetBottom: offsetBottom,
>             stickyOffsetTop: 0,
452,462c443,452
<               setHasStickyBackground
<             }}>
<             <DynamicOverlapContext.Provider
<               value={updateBackgroundOverlapHeight}>
<               {children}
<             </DynamicOverlapContext.Provider>
<           </AppLayoutContext.Provider>
<         </AppLayoutInternalsContext.Provider>
<       )
<     }
<   )
---
>             setHasStickyBackground
>           }}>
>           <DynamicOverlapContext.Provider
>             value={updateBackgroundOverlapHeight}>
>             {children}
>           </DynamicOverlapContext.Provider>
>         </AppLayoutContext.Provider>
>       </AppLayoutInternalsContext.Provider>
>     )
>   })
diff -r src/components/app-layout/visual-refresh/drawers.jsx ../cloudcomp/lib/components/app-layout/visual-refresh/drawers.jsx
24c24
<     isNavigationOpen,
---
>     navigationOpen,
29c29
<     hasDrawerViewportOverlay && isNavigationOpen && !navigationHide
---
>     hasDrawerViewportOverlay && navigationOpen && !navigationHide
57c57
<     isNavigationOpen,
---
>     navigationOpen,
78,79c78
<     isHidden ||
<     (hasDrawerViewportOverlay && isNavigationOpen && !navigationHide)
---
>     isHidden || (hasDrawerViewportOverlay && navigationOpen && !navigationHide)
219,244c218,245
<         {visibleItems.map(item => {
<           return (
<             <TriggerButton
<               ariaLabel={item.ariaLabels?.triggerButton}
<               ariaExpanded={item.id === activeDrawerId}
<               ariaControls={activeDrawerId === item.id ? item.id : void 0}
<               className={clsx(
<                 styles['drawers-trigger'],
<                 testutilStyles['drawers-trigger'],
<                 item.id === TOOLS_DRAWER_ID && testutilStyles['tools-toggle']
<               )}
<               iconName={item.trigger.iconName}
<               iconSvg={item.trigger.iconSvg}
<               key={item.id}
<               onClick={() => handleDrawersClick(item.id)}
<               ref={
<                 item.id === previousActiveDrawerId.current
<                   ? drawersRefs.toggle
<                   : void 0
<               }
<               selected={item.id === activeDrawerId}
<               badge={item.badge}
<               testId={`awsui-app-layout-trigger-${item.id}`}
<             />
<           )
<         })}
---
>         {visibleItems.map(
>           memo(item => {
>             return (
>               <TriggerButton
>                 ariaLabel={item.ariaLabels?.triggerButton}
>                 ariaExpanded={item.id === activeDrawerId}
>                 ariaControls={activeDrawerId === item.id ? item.id : void 0}
>                 className={clsx(
>                   styles['drawers-trigger'],
>                   testutilStyles['drawers-trigger'],
>                   item.id === TOOLS_DRAWER_ID && testutilStyles['tools-toggle']
>                 )}
>                 iconName={item.trigger.iconName}
>                 iconSvg={item.trigger.iconSvg}
>                 key={item.id}
>                 onClick={() => handleDrawersClick(item.id)}
>                 ref={
>                   item.id === previousActiveDrawerId.current
>                     ? drawersRefs.toggle
>                     : void 0
>                 }
>                 selected={item.id === activeDrawerId}
>                 badge={item.badge}
>                 testId={`awsui-app-layout-trigger-${item.id}`}
>               />
>             )
>           })
>         )}
253,272c254,275
<             customTriggerBuilder={({
<               onClick,
<               triggerRef,
<               ariaLabel,
<               ariaExpanded,
<               testUtilsClass
<             }) => (
<               <TriggerButton
<                 ref={triggerRef}
<                 ariaLabel={ariaLabel}
<                 ariaExpanded={ariaExpanded}
<                 badge={overflowMenuHasBadge}
<                 className={clsx(
<                   styles['drawers-trigger'],
<                   testutilStyles['drawers-trigger'],
<                   testUtilsClass
<                 )}
<                 iconName='ellipsis'
<                 onClick={onClick}
<               />
---
>             customTriggerBuilder={memo(
>               ({
>                 onClick,
>                 triggerRef,
>                 ariaLabel,
>                 ariaExpanded,
>                 testUtilsClass
>               }) => (
>                 <TriggerButton
>                   ref={triggerRef}
>                   ariaLabel={ariaLabel}
>                   ariaExpanded={ariaExpanded}
>                   badge={overflowMenuHasBadge}
>                   className={clsx(
>                     styles['drawers-trigger'],
>                     testutilStyles['drawers-trigger'],
>                     testUtilsClass
>                   )}
>                   iconName='ellipsis'
>                   onClick={onClick}
>                 />
>               )
331,358c334,363
<         {visibleItems.map(item => (
<           <InternalButton
<             ariaExpanded={item.id === activeDrawerId}
<             ariaLabel={item.ariaLabels?.triggerButton}
<             className={clsx(
<               styles['drawers-trigger'],
<               testutilStyles['drawers-trigger'],
<               item.id === TOOLS_DRAWER_ID && testutilStyles['tools-toggle']
<             )}
<             disabled={hasDrawerViewportOverlay}
<             ref={
<               item.id === previousActiveDrawerId.current
<                 ? drawersRefs.toggle
<                 : void 0
<             }
<             formAction='none'
<             iconName={item.trigger.iconName}
<             iconSvg={item.trigger.iconSvg}
<             badge={item.badge}
<             key={item.id}
<             onClick={() => handleDrawersClick(item.id)}
<             variant='icon'
<             __nativeAttributes={{
<               'aria-haspopup': true,
<               'data-testid': `awsui-app-layout-trigger-${item.id}`
<             }}
<           />
<         ))}
---
>         {visibleItems.map(
>           memo(item => (
>             <InternalButton
>               ariaExpanded={item.id === activeDrawerId}
>               ariaLabel={item.ariaLabels?.triggerButton}
>               className={clsx(
>                 styles['drawers-trigger'],
>                 testutilStyles['drawers-trigger'],
>                 item.id === TOOLS_DRAWER_ID && testutilStyles['tools-toggle']
>               )}
>               disabled={hasDrawerViewportOverlay}
>               ref={
>                 item.id === previousActiveDrawerId.current
>                   ? drawersRefs.toggle
>                   : void 0
>               }
>               formAction='none'
>               iconName={item.trigger.iconName}
>               iconSvg={item.trigger.iconSvg}
>               badge={item.badge}
>               key={item.id}
>               onClick={() => handleDrawersClick(item.id)}
>               variant='icon'
>               __nativeAttributes={{
>                 'aria-haspopup': true,
>                 'data-testid': `awsui-app-layout-trigger-${item.id}`
>               }}
>             />
>           ))
>         )}
diff -r src/components/app-layout/visual-refresh/index.jsx ../cloudcomp/lib/components/app-layout/visual-refresh/index.jsx
1c1
< import {forwardRef, memo} from 'react'
---
> import {forwardRef} from 'react'
15,38c15,36
< const AppLayoutWithRef = memo(
<   forwardRef((props, ref) => {
<     return (
<       <AppLayoutInternalsProvider {...props} ref={ref}>
<         <SplitPanel>
<           <Layout>
<             <Background />
<             <Navigation />
<             <MobileToolbar />
<             <Notifications />
<             <Breadcrumbs />
<             <Header />
<             <Main />
<             <SplitPanel.Bottom />
<             <Tools>
<               <SplitPanel.Side />
<             </Tools>
<             <Drawers />
<           </Layout>
<         </SplitPanel>
<       </AppLayoutInternalsProvider>
<     )
<   })
< )
---
> const AppLayoutWithRef = forwardRef(function AppLayout(props, ref) {
>   return (
>     <AppLayoutInternalsProvider {...props} ref={ref}>
>       <SplitPanel>
>         <Layout>
>           <Background />
>           <Navigation />
>           <MobileToolbar />
>           <Notifications />
>           <Breadcrumbs />
>           <Header />
>           <Main />
>           <SplitPanel.Bottom />
>           <Tools>
>             <SplitPanel.Side />
>           </Tools>
>           <Drawers />
>         </Layout>
>       </SplitPanel>
>     </AppLayoutInternalsProvider>
>   )
> })
diff -r src/components/app-layout/visual-refresh/layout.jsx ../cloudcomp/lib/components/app-layout/visual-refresh/layout.jsx
23c23
<     isNavigationOpen,
---
>     navigationOpen,
42c42
<   const hasContentGapLeft = isNavigationOpen || navigationHide
---
>   const hasContentGapLeft = navigationOpen || navigationHide
diff -r src/components/app-layout/visual-refresh/main.jsx ../cloudcomp/lib/components/app-layout/visual-refresh/main.jsx
14c14
<     isNavigationOpen,
---
>     navigationOpen,
32c32
<           [styles['is-navigation-open']]: isNavigationOpen,
---
>           [styles['is-navigation-open']]: navigationOpen,
diff -r src/components/app-layout/visual-refresh/mobile-toolbar.jsx ../cloudcomp/lib/components/app-layout/visual-refresh/mobile-toolbar.jsx
20c20
<     isNavigationOpen,
---
>     navigationOpen,
54c54
<           aria-hidden={isNavigationOpen}
---
>           aria-hidden={navigationOpen}
56c56
<             [testutilStyles['drawer-closed']]: !isNavigationOpen
---
>             [testutilStyles['drawer-closed']]: !navigationOpen
60c60
<             ariaExpanded={isNavigationOpen ? void 0 : false}
---
>             ariaExpanded={navigationOpen ? void 0 : false}
69c69
<               'aria-haspopup': isNavigationOpen ? void 0 : true
---
>               'aria-haspopup': navigationOpen ? void 0 : true
diff -r src/components/app-layout/visual-refresh/navigation.jsx ../cloudcomp/lib/components/app-layout/visual-refresh/navigation.jsx
19c19
<     isNavigationOpen,
---
>     navigationOpen,
41c41
<     (!isNavigationOpen || (isToolsOpen && !toolsHide))
---
>     (!navigationOpen || (isToolsOpen && !toolsHide))
43,44c43,44
<     <Transition in={isNavigationOpen}>
<       {(state, transitionEventsRef) => (
---
>     <Transition in={navigationOpen}>
>       {memo((state, transitionEventsRef) => (
49c49
<             [testutilStyles['drawer-closed']]: !isNavigationOpen
---
>             [testutilStyles['drawer-closed']]: !navigationOpen
51,55c51
<           style={{
<             ...(navigationWidth && {
<               [customCssProps.navigationWidth]: `${navigationWidth}px`
<             })
<           }}>
---
>           style={{[customCssProps.navigationWidth]: `${navigationWidth}px`}}>
58c54
<               aria-hidden={isMobile || isNavigationOpen ? true : false}
---
>               aria-hidden={isMobile || navigationOpen}
62c58
<                 [styles['is-navigation-open']]: isNavigationOpen
---
>                 [styles['is-navigation-open']]: navigationOpen
67c63
<                 ariaExpanded={isNavigationOpen ? void 0 : false}
---
>                 ariaExpanded={navigationOpen ? void 0 : false}
81c77
<                 [styles['is-navigation-open']]: isNavigationOpen
---
>                 [styles['is-navigation-open']]: navigationOpen
86c82
<             aria-hidden={!isNavigationOpen}
---
>             aria-hidden={!navigationOpen}
106c102
<       )}
---
>       ))}
diff -r src/components/app-layout/visual-refresh/split-panel.jsx ../cloudcomp/lib/components/app-layout/visual-refresh/split-panel.jsx
5c5
< import {SplitPanelProvider} from '../split-panel'
---
> import {SPLIT_PANEL_MIN_WIDTH, SplitPanelProvider} from '../split-panel'
60c60
<     isNavigationOpen,
---
>     navigationOpen,
72c72
<       {(state, transitionEventsRef) => (
---
>       {memo((state, transitionEventsRef) => (
81c81
<               [styles['is-navigation-open']]: isNavigationOpen,
---
>               [styles['is-navigation-open']]: navigationOpen,
93c93
<       )}
---
>       ))}
104d103
<     splitPanelMinWidth,
128c127
<         [customCssProps.splitPanelMinWidth]: `${splitPanelMinWidth}px`
---
>         [customCssProps.splitPanelMinWidth]: `${SPLIT_PANEL_MIN_WIDTH}px`
diff -r src/components/app-layout/visual-refresh/styles.css.js ../cloudcomp/lib/components/app-layout/visual-refresh/styles.css.js
2,10c2,10
<   background: 'awsui_background_hyvsj_1p4u3_147',
<   'scrolling-background': 'awsui_scrolling-background_hyvsj_1p4u3_150',
<   'sticky-background': 'awsui_sticky-background_hyvsj_1p4u3_156',
<   'has-sticky-notifications': 'awsui_has-sticky-notifications_hyvsj_1p4u3_164',
<   breadcrumbs: 'awsui_breadcrumbs_hyvsj_1p4u3_175',
<   'has-sticky-background': 'awsui_has-sticky-background_hyvsj_1p4u3_185',
<   'drawers-container': 'awsui_drawers-container_hyvsj_1p4u3_197',
<   'has-open-drawer': 'awsui_has-open-drawer_hyvsj_1p4u3_208',
<   'disable-body-scroll': 'awsui_disable-body-scroll_hyvsj_1p4u3_231',
---
>   background: 'awsui_background_hyvsj_1o26t_147',
>   'scrolling-background': 'awsui_scrolling-background_hyvsj_1o26t_150',
>   'sticky-background': 'awsui_sticky-background_hyvsj_1o26t_156',
>   'has-sticky-notifications': 'awsui_has-sticky-notifications_hyvsj_1o26t_164',
>   breadcrumbs: 'awsui_breadcrumbs_hyvsj_1o26t_175',
>   'has-sticky-background': 'awsui_has-sticky-background_hyvsj_1o26t_185',
>   'drawers-container': 'awsui_drawers-container_hyvsj_1o26t_197',
>   'has-open-drawer': 'awsui_has-open-drawer_hyvsj_1o26t_208',
>   'disable-body-scroll': 'awsui_disable-body-scroll_hyvsj_1o26t_231',
12,13c12,13
<     'awsui_drawers-desktop-triggers-container_hyvsj_1p4u3_236',
<   'has-multiple-triggers': 'awsui_has-multiple-triggers_hyvsj_1p4u3_277',
---
>     'awsui_drawers-desktop-triggers-container_hyvsj_1o26t_236',
>   'has-multiple-triggers': 'awsui_has-multiple-triggers_hyvsj_1o26t_277',
15,35c15,35
<     'awsui_drawers-mobile-triggers-container_hyvsj_1p4u3_287',
<   'drawers-trigger-content': 'awsui_drawers-trigger-content_hyvsj_1p4u3_291',
<   'drawers-trigger-overflow': 'awsui_drawers-trigger-overflow_hyvsj_1p4u3_305',
<   'drawers-trigger': 'awsui_drawers-trigger_hyvsj_1p4u3_291',
<   drawer: 'awsui_drawer_hyvsj_1p4u3_197',
<   'drawer-content-container': 'awsui_drawer-content-container_hyvsj_1p4u3_336',
<   'drawer-close-button': 'awsui_drawer-close-button_hyvsj_1p4u3_345',
<   'drawer-content': 'awsui_drawer-content_hyvsj_1p4u3_336',
<   'drawer-content-hidden': 'awsui_drawer-content-hidden_hyvsj_1p4u3_353',
<   'drawer-slider': 'awsui_drawer-slider_hyvsj_1p4u3_356',
<   'is-drawer-open': 'awsui_is-drawer-open_hyvsj_1p4u3_363',
<   content: 'awsui_content_hyvsj_1p4u3_389',
<   layout: 'awsui_layout_hyvsj_1p4u3_414',
<   'has-max-content-width': 'awsui_has-max-content-width_hyvsj_1p4u3_497',
<   'content-type-dashboard': 'awsui_content-type-dashboard_hyvsj_1p4u3_512',
<   'content-type-table': 'awsui_content-type-table_hyvsj_1p4u3_526',
<   'content-type-cards': 'awsui_content-type-cards_hyvsj_1p4u3_526',
<   'is-overlap-disabled': 'awsui_is-overlap-disabled_hyvsj_1p4u3_532',
<   'is-hide-mobile-toolbar': 'awsui_is-hide-mobile-toolbar_hyvsj_1p4u3_535',
<   'has-content-gap-left': 'awsui_has-content-gap-left_hyvsj_1p4u3_561',
<   'has-content-gap-right': 'awsui_has-content-gap-right_hyvsj_1p4u3_564',
---
>     'awsui_drawers-mobile-triggers-container_hyvsj_1o26t_287',
>   'drawers-trigger-content': 'awsui_drawers-trigger-content_hyvsj_1o26t_291',
>   'drawers-trigger-overflow': 'awsui_drawers-trigger-overflow_hyvsj_1o26t_305',
>   'drawers-trigger': 'awsui_drawers-trigger_hyvsj_1o26t_291',
>   drawer: 'awsui_drawer_hyvsj_1o26t_197',
>   'drawer-content-container': 'awsui_drawer-content-container_hyvsj_1o26t_336',
>   'drawer-close-button': 'awsui_drawer-close-button_hyvsj_1o26t_345',
>   'drawer-content': 'awsui_drawer-content_hyvsj_1o26t_336',
>   'drawer-content-hidden': 'awsui_drawer-content-hidden_hyvsj_1o26t_353',
>   'drawer-slider': 'awsui_drawer-slider_hyvsj_1o26t_356',
>   'is-drawer-open': 'awsui_is-drawer-open_hyvsj_1o26t_363',
>   content: 'awsui_content_hyvsj_1o26t_389',
>   layout: 'awsui_layout_hyvsj_1o26t_414',
>   'has-max-content-width': 'awsui_has-max-content-width_hyvsj_1o26t_497',
>   'content-type-dashboard': 'awsui_content-type-dashboard_hyvsj_1o26t_512',
>   'content-type-table': 'awsui_content-type-table_hyvsj_1o26t_526',
>   'content-type-cards': 'awsui_content-type-cards_hyvsj_1o26t_526',
>   'is-overlap-disabled': 'awsui_is-overlap-disabled_hyvsj_1o26t_532',
>   'is-hide-mobile-toolbar': 'awsui_is-hide-mobile-toolbar_hyvsj_1o26t_535',
>   'has-content-gap-left': 'awsui_has-content-gap-left_hyvsj_1o26t_561',
>   'has-content-gap-right': 'awsui_has-content-gap-right_hyvsj_1o26t_564',
37,38c37,38
<     'awsui_content-first-child-notifications_hyvsj_1p4u3_574',
<   'has-breadcrumbs': 'awsui_has-breadcrumbs_hyvsj_1p4u3_577',
---
>     'awsui_content-first-child-notifications_hyvsj_1o26t_574',
>   'has-breadcrumbs': 'awsui_has-breadcrumbs_hyvsj_1o26t_577',
40,44c40,44
<     'awsui_content-first-child-header_hyvsj_1p4u3_580',
<   'has-header': 'awsui_has-header_hyvsj_1p4u3_580',
<   'content-first-child-main': 'awsui_content-first-child-main_hyvsj_1p4u3_601',
<   'disable-content-paddings': 'awsui_disable-content-paddings_hyvsj_1p4u3_601',
<   'has-split-panel': 'awsui_has-split-panel_hyvsj_1p4u3_644',
---
>     'awsui_content-first-child-header_hyvsj_1o26t_580',
>   'has-header': 'awsui_has-header_hyvsj_1o26t_580',
>   'content-first-child-main': 'awsui_content-first-child-main_hyvsj_1o26t_601',
>   'disable-content-paddings': 'awsui_disable-content-paddings_hyvsj_1o26t_601',
>   'has-split-panel': 'awsui_has-split-panel_hyvsj_1o26t_644',
46,52c46,52
<     'awsui_split-panel-position-bottom_hyvsj_1p4u3_644',
<   'block-body-scroll': 'awsui_block-body-scroll_hyvsj_1p4u3_658',
<   unfocusable: 'awsui_unfocusable_hyvsj_1p4u3_663',
<   container: 'awsui_container_hyvsj_1p4u3_673',
<   'is-navigation-open': 'awsui_is-navigation-open_hyvsj_1p4u3_699',
<   'is-tools-open': 'awsui_is-tools-open_hyvsj_1p4u3_702',
<   'is-split-panel-open': 'awsui_is-split-panel-open_hyvsj_1p4u3_702',
---
>     'awsui_split-panel-position-bottom_hyvsj_1o26t_644',
>   'block-body-scroll': 'awsui_block-body-scroll_hyvsj_1o26t_658',
>   unfocusable: 'awsui_unfocusable_hyvsj_1o26t_663',
>   container: 'awsui_container_hyvsj_1o26t_673',
>   'is-navigation-open': 'awsui_is-navigation-open_hyvsj_1o26t_699',
>   'is-tools-open': 'awsui_is-tools-open_hyvsj_1o26t_702',
>   'is-split-panel-open': 'awsui_is-split-panel-open_hyvsj_1o26t_702',
54,56c54,56
<     'awsui_split-panel-position-side_hyvsj_1p4u3_702',
<   'has-active-drawer': 'awsui_has-active-drawer_hyvsj_1p4u3_702',
<   'mobile-toolbar': 'awsui_mobile-toolbar_hyvsj_1p4u3_711',
---
>     'awsui_split-panel-position-side_hyvsj_1o26t_702',
>   'has-active-drawer': 'awsui_has-active-drawer_hyvsj_1o26t_702',
>   'mobile-toolbar': 'awsui_mobile-toolbar_hyvsj_1o26t_711',
58,59c58,59
<     'awsui_remove-high-contrast-header_hyvsj_1p4u3_728',
<   'mobile-toolbar-nav': 'awsui_mobile-toolbar-nav_hyvsj_1p4u3_732',
---
>     'awsui_remove-high-contrast-header_hyvsj_1o26t_728',
>   'mobile-toolbar-nav': 'awsui_mobile-toolbar-nav_hyvsj_1o26t_732',
61,80c61,80
<     'awsui_mobile-toolbar-breadcrumbs_hyvsj_1p4u3_736',
<   'mobile-toolbar-tools': 'awsui_mobile-toolbar-tools_hyvsj_1p4u3_740',
<   'navigation-container': 'awsui_navigation-container_hyvsj_1p4u3_749',
<   'show-navigation': 'awsui_show-navigation_hyvsj_1p4u3_793',
<   animating: 'awsui_animating_hyvsj_1p4u3_816',
<   showButtons: 'awsui_showButtons_hyvsj_1p4u3_1',
<   navigation: 'awsui_navigation_hyvsj_1p4u3_749',
<   openNavigation: 'awsui_openNavigation_hyvsj_1p4u3_1',
<   'animated-content': 'awsui_animated-content_hyvsj_1p4u3_878',
<   'hide-navigation': 'awsui_hide-navigation_hyvsj_1p4u3_887',
<   notifications: 'awsui_notifications_hyvsj_1p4u3_897',
<   'sticky-notifications': 'awsui_sticky-notifications_hyvsj_1p4u3_903',
<   'split-panel-bottom': 'awsui_split-panel-bottom_hyvsj_1p4u3_920',
<   'position-bottom': 'awsui_position-bottom_hyvsj_1p4u3_967',
<   openSplitPanelBottom: 'awsui_openSplitPanelBottom_hyvsj_1p4u3_1',
<   'split-panel-side': 'awsui_split-panel-side_hyvsj_1p4u3_996',
<   'position-side': 'awsui_position-side_hyvsj_1p4u3_1009',
<   'tools-container': 'awsui_tools-container_hyvsj_1p4u3_1031',
<   tools: 'awsui_tools_hyvsj_1p4u3_1031',
<   openTools: 'awsui_openTools_hyvsj_1p4u3_1',
---
>     'awsui_mobile-toolbar-breadcrumbs_hyvsj_1o26t_736',
>   'mobile-toolbar-tools': 'awsui_mobile-toolbar-tools_hyvsj_1o26t_740',
>   'navigation-container': 'awsui_navigation-container_hyvsj_1o26t_749',
>   'show-navigation': 'awsui_show-navigation_hyvsj_1o26t_787',
>   animating: 'awsui_animating_hyvsj_1o26t_810',
>   showButtons: 'awsui_showButtons_hyvsj_1o26t_1',
>   navigation: 'awsui_navigation_hyvsj_1o26t_749',
>   openNavigation: 'awsui_openNavigation_hyvsj_1o26t_1',
>   'animated-content': 'awsui_animated-content_hyvsj_1o26t_872',
>   'hide-navigation': 'awsui_hide-navigation_hyvsj_1o26t_881',
>   notifications: 'awsui_notifications_hyvsj_1o26t_891',
>   'sticky-notifications': 'awsui_sticky-notifications_hyvsj_1o26t_897',
>   'split-panel-bottom': 'awsui_split-panel-bottom_hyvsj_1o26t_914',
>   'position-bottom': 'awsui_position-bottom_hyvsj_1o26t_961',
>   openSplitPanelBottom: 'awsui_openSplitPanelBottom_hyvsj_1o26t_1',
>   'split-panel-side': 'awsui_split-panel-side_hyvsj_1o26t_990',
>   'position-side': 'awsui_position-side_hyvsj_1o26t_1003',
>   'tools-container': 'awsui_tools-container_hyvsj_1o26t_1025',
>   tools: 'awsui_tools_hyvsj_1o26t_1025',
>   openTools: 'awsui_openTools_hyvsj_1o26t_1',
82,91c82,91
<     'awsui_has-tools-form-persistence_hyvsj_1p4u3_1128',
<   'hide-tools': 'awsui_hide-tools_hyvsj_1p4u3_1138',
<   'show-tools': 'awsui_show-tools_hyvsj_1p4u3_1150',
<   'has-tools-form': 'awsui_has-tools-form_hyvsj_1p4u3_1128',
<   'trigger-badge-wrapper': 'awsui_trigger-badge-wrapper_hyvsj_1p4u3_1233',
<   trigger: 'awsui_trigger_hyvsj_1p4u3_1233',
<   selected: 'awsui_selected_hyvsj_1p4u3_1307',
<   badge: 'awsui_badge_hyvsj_1p4u3_1327',
<   'trigger-wrapper': 'awsui_trigger-wrapper_hyvsj_1p4u3_1331',
<   dot: 'awsui_dot_hyvsj_1p4u3_1342'
---
>     'awsui_has-tools-form-persistence_hyvsj_1o26t_1116',
>   'hide-tools': 'awsui_hide-tools_hyvsj_1o26t_1126',
>   'show-tools': 'awsui_show-tools_hyvsj_1o26t_1138',
>   'has-tools-form': 'awsui_has-tools-form_hyvsj_1o26t_1116',
>   'trigger-badge-wrapper': 'awsui_trigger-badge-wrapper_hyvsj_1o26t_1221',
>   trigger: 'awsui_trigger_hyvsj_1o26t_1221',
>   selected: 'awsui_selected_hyvsj_1o26t_1295',
>   badge: 'awsui_badge_hyvsj_1o26t_1315',
>   'trigger-wrapper': 'awsui_trigger-wrapper_hyvsj_1o26t_1319',
>   dot: 'awsui_dot_hyvsj_1o26t_1330'
diff -r src/components/app-layout/visual-refresh/tools.jsx ../cloudcomp/lib/components/app-layout/visual-refresh/tools.jsx
19d18
<     hasDefaultToolsWidth,
59c58
<       {(state, transitionEventsRef) => (
---
>       {memo((state, transitionEventsRef) => (
70,73c69
< 
<             [customCssProps.toolsWidth]: hasDefaultToolsWidth
<               ? ''
<               : `${toolsWidth}px`
---
>             [customCssProps.toolsWidth]: `${toolsWidth}px`
154c150
<       )}
---
>       ))}
diff -r src/components/app-layout/widget.jsx ../cloudcomp/lib/components/app-layout/widget.jsx
1c1
< import {forwardRef} from 'react'
---
> import {forwardRef, memo} from 'react'
6,14c6,16
< const createWidgetizedAppLayout = AppLayoutLoader => {
<   return forwardRef((props, ref) => {
<     const isRefresh = useVisualRefresh()
<     if (isRefresh && getGlobalFlag('appLayoutWidget') && AppLayoutLoader) {
<       return <AppLayoutLoader ref={ref} {...props} />
<     }
<     return <AppLayoutImplementation ref={ref} {...props} />
<   })
< }
---
> const createWidgetizedAppLayout = memo(AppLayoutLoader => {
>   return memo(
>     forwardRef((props, ref) => {
>       const isRefresh = useVisualRefresh()
>       if (isRefresh && getGlobalFlag('appLayoutWidget') && AppLayoutLoader) {
>         return <AppLayoutLoader ref={ref} {...props} />
>       }
>       return <AppLayoutImplementation ref={ref} {...props} />
>     })
>   )
> })
diff -r src/components/area-chart/elements/data-series.jsx ../cloudcomp/lib/components/area-chart/elements/data-series.jsx
41,73c41,75
<         {seriesData.map(([series, data]) => {
<           const isHighlighted = series === highlightedSeries
<           const isDimmed = !!highlightedSeries && !isHighlighted
<           return (
<             <g
<               key={series.title}
<               role='group'
<               aria-label={series.title}
<               className={clsx(
<                 styles.series,
<                 styles[`series--${series.type}`],
<                 {
<                   [styles['series--highlighted']]: isHighlighted,
<                   [styles['series--dimmed']]: useHighlightDimmed && isDimmed
<                 }
<               )}>
<               {series.type === 'area' ? (
<                 <AreaSeries
<                   data={data}
<                   color={model.getInternalSeries(series).color}
<                   chartAreaClipPath={chartAreaClipPath}
<                 />
<               ) : (
<                 <ThresholdSeries
<                   data={data}
<                   xScale={model.computed.xScale}
<                   color={model.getInternalSeries(series).color}
<                   chartAreaClipPath={chartAreaClipPath}
<                 />
<               )}
<             </g>
<           )
<         })}
---
>         {seriesData.map(
>           memo(([series, data]) => {
>             const isHighlighted = series === highlightedSeries
>             const isDimmed = !!highlightedSeries && !isHighlighted
>             return (
>               <g
>                 key={series.title}
>                 role='group'
>                 aria-label={series.title}
>                 className={clsx(
>                   styles.series,
>                   styles[`series--${series.type}`],
>                   {
>                     [styles['series--highlighted']]: isHighlighted,
>                     [styles['series--dimmed']]: useHighlightDimmed && isDimmed
>                   }
>                 )}>
>                 {series.type === 'area' ? (
>                   <AreaSeries
>                     data={data}
>                     color={model.getInternalSeries(series).color}
>                     chartAreaClipPath={chartAreaClipPath}
>                   />
>                 ) : (
>                   <ThresholdSeries
>                     data={data}
>                     xScale={model.computed.xScale}
>                     color={model.getInternalSeries(series).color}
>                     chartAreaClipPath={chartAreaClipPath}
>                   />
>                 )}
>               </g>
>             )
>           })
>         )}
diff -r src/components/autosuggest/plain-list.jsx ../cloudcomp/lib/components/autosuggest/plain-list.jsx
54,76c54,78
<         {autosuggestItemsState.items.map((item, index) => {
<           const optionProps = getOptionProps(
<             index,
<             item,
<             autosuggestItemsState.items,
<             highlightedA11yProps,
<             autosuggestItemsState.highlightedOption,
<             hasDropdownStatus
<           )
<           return (
<             <AutosuggestOption
<               highlightText={highlightText}
<               option={item}
<               highlighted={item === autosuggestItemsState.highlightedOption}
<               current={item.value === highlightText}
<               key={index}
<               data-mouse-target={index}
<               screenReaderContent={screenReaderContent}
<               highlightType={autosuggestItemsState.highlightType}
<               {...optionProps}
<             />
<           )
<         })}
---
>         {autosuggestItemsState.items.map(
>           memo((item, index) => {
>             const optionProps = getOptionProps(
>               index,
>               item,
>               autosuggestItemsState.items,
>               highlightedA11yProps,
>               autosuggestItemsState.highlightedOption,
>               hasDropdownStatus
>             )
>             return (
>               <AutosuggestOption
>                 highlightText={highlightText}
>                 option={item}
>                 highlighted={item === autosuggestItemsState.highlightedOption}
>                 current={item.value === highlightText}
>                 key={index}
>                 data-mouse-target={index}
>                 screenReaderContent={screenReaderContent}
>                 highlightType={autosuggestItemsState.highlightType}
>                 {...optionProps}
>               />
>             )
>           })
>         )}
diff -r src/components/breadcrumb-group/internal.jsx ../cloudcomp/lib/components/breadcrumb-group/internal.jsx
14,40c14,34
< const getDropdownTrigger = ({
<   ariaLabel,
<   triggerRef,
<   disabled,
<   testUtilsClass,
<   isOpen,
<   onClick
< }) => {
<   return (
<     <InternalButton
<       ref={triggerRef}
<       className={testUtilsClass}
<       disabled={disabled}
<       onClick={event => {
<         event.preventDefault()
<         onClick()
<       }}
<       ariaExpanded={isOpen}
<       aria-haspopup={true}
<       ariaLabel={ariaLabel}
<       variant='breadcrumb-group'
<       formAction='none'>
<       ...
<     </InternalButton>
<   )
< }
< 
---
> const getDropdownTrigger = memo(
>   ({ariaLabel, triggerRef, disabled, testUtilsClass, isOpen, onClick}) => {
>     return (
>       <InternalButton
>         ref={triggerRef}
>         className={testUtilsClass}
>         disabled={disabled}
>         onClick={event => {
>           event.preventDefault()
>           onClick()
>         }}
>         ariaExpanded={isOpen}
>         aria-haspopup={true}
>         ariaLabel={ariaLabel}
>         variant='breadcrumb-group'
>         formAction='none'>
>         ...
>       </InternalButton>
>     )
>   }
> )
79,93c73,89
<     let breadcrumbItems = items.map((item, index) => {
<       const isLast = index === items.length - 1
<       return (
<         <li className={styles.item} key={index}>
<           <BreadcrumbItem
<             item={item}
<             onClick={onClick}
<             onFollow={onFollow}
<             isCompressed={isMobile}
<             isLast={isLast}
<             isDisplayed={!isMobile || isLast || index === 0}
<           />
<         </li>
<       )
<     })
---
>     let breadcrumbItems = items.map(
>       memo((item, index) => {
>         const isLast = index === items.length - 1
>         return (
>           <li className={styles.item} key={index}>
>             <BreadcrumbItem
>               item={item}
>               onClick={onClick}
>               onFollow={onFollow}
>               isCompressed={isMobile}
>               isLast={isLast}
>               isDisplayed={!isMobile || isLast || index === 0}
>             />
>           </li>
>         )
>       })
>     )
diff -r src/components/button-dropdown/internal.jsx ../cloudcomp/lib/components/button-dropdown/internal.jsx
63a64
> 
diff -r src/components/button-dropdown/items-list.jsx ../cloudcomp/lib/components/button-dropdown/items-list.jsx
27,31c27,83
<     const elements = items.map((item, index) => {
<       if (!isItemGroup(item)) {
<         const showDivider =
<           (index === items.length - 1 && !lastInDropdown) ||
<           isItemGroup(items[index + 1])
---
>     const elements = items.map(
>       memo((item, index) => {
>         if (!isItemGroup(item)) {
>           const showDivider =
>             (index === items.length - 1 && !lastInDropdown) ||
>             isItemGroup(items[index + 1])
>           return (
>             <ItemElement
>               key={index}
>               item={item}
>               onItemActivate={onItemActivate}
>               disabled={item.disabled ?? categoryDisabled}
>               highlighted={isHighlighted(item)}
>               isKeyboardHighlighted={isKeyboardHighlight(item)}
>               highlightItem={highlightItem}
>               showDivider={showDivider}
>               hasCategoryHeader={hasCategoryHeader}
>               variant={variant}
>             />
>           )
>         }
>         if (hasExpandableGroups) {
>           return item.text ? (
>             isMobile ? (
>               <MobileExpandableCategoryElement
>                 key={index}
>                 item={item}
>                 onItemActivate={onItemActivate}
>                 onGroupToggle={onGroupToggle}
>                 targetItem={targetItem}
>                 isHighlighted={isHighlighted}
>                 isKeyboardHighlight={isKeyboardHighlight}
>                 isExpanded={isExpanded}
>                 lastInDropdown={lastInDropdown && index === items.length - 1}
>                 highlightItem={highlightItem}
>                 disabled={item.disabled ?? false}
>                 variant={variant}
>               />
>             ) : (
>               <ExpandableCategoryElement
>                 key={index}
>                 item={item}
>                 onItemActivate={onItemActivate}
>                 onGroupToggle={onGroupToggle}
>                 targetItem={targetItem}
>                 isHighlighted={isHighlighted}
>                 isKeyboardHighlight={isKeyboardHighlight}
>                 isExpanded={isExpanded}
>                 lastInDropdown={true}
>                 highlightItem={highlightItem}
>                 disabled={item.disabled ?? false}
>                 expandToViewport={expandToViewport}
>                 variant={variant}
>               />
>             )
>           ) : null
>         }
33c85
<           <ItemElement
---
>           <CategoryElement
37,39c89,94
<             disabled={item.disabled ?? categoryDisabled}
<             highlighted={isHighlighted(item)}
<             isKeyboardHighlighted={isKeyboardHighlight(item)}
---
>             onGroupToggle={onGroupToggle}
>             targetItem={targetItem}
>             isHighlighted={isHighlighted}
>             isKeyboardHighlight={isKeyboardHighlight}
>             isExpanded={isExpanded}
>             lastInDropdown={lastInDropdown && index === items.length - 1}
41,42c96
<             showDivider={showDivider}
<             hasCategoryHeader={hasCategoryHeader}
---
>             disabled={item.disabled ?? false}
46,99c100,101
<       }
<       if (hasExpandableGroups) {
<         return item.text ? (
<           isMobile ? (
<             <MobileExpandableCategoryElement
<               key={index}
<               item={item}
<               onItemActivate={onItemActivate}
<               onGroupToggle={onGroupToggle}
<               targetItem={targetItem}
<               isHighlighted={isHighlighted}
<               isKeyboardHighlight={isKeyboardHighlight}
<               isExpanded={isExpanded}
<               lastInDropdown={lastInDropdown && index === items.length - 1}
<               highlightItem={highlightItem}
<               disabled={item.disabled ?? false}
<               variant={variant}
<             />
<           ) : (
<             <ExpandableCategoryElement
<               key={index}
<               item={item}
<               onItemActivate={onItemActivate}
<               onGroupToggle={onGroupToggle}
<               targetItem={targetItem}
<               isHighlighted={isHighlighted}
<               isKeyboardHighlight={isKeyboardHighlight}
<               isExpanded={isExpanded}
<               lastInDropdown={true}
<               highlightItem={highlightItem}
<               disabled={item.disabled ?? false}
<               expandToViewport={expandToViewport}
<               variant={variant}
<             />
<           )
<         ) : null
<       }
<       return (
<         <CategoryElement
<           key={index}
<           item={item}
<           onItemActivate={onItemActivate}
<           onGroupToggle={onGroupToggle}
<           targetItem={targetItem}
<           isHighlighted={isHighlighted}
<           isKeyboardHighlight={isKeyboardHighlight}
<           isExpanded={isExpanded}
<           lastInDropdown={lastInDropdown && index === items.length - 1}
<           highlightItem={highlightItem}
<           disabled={item.disabled ?? false}
<           variant={variant}
<         />
<       )
<     })
---
>       })
>     )
diff -r src/components/button-dropdown/tooltip.jsx ../cloudcomp/lib/components/button-dropdown/tooltip.jsx
28c28
<               arrow={position2 => <Arrow position={position2} />}
---
>               arrow={memo(position2 => <Arrow position={position2} />)}
diff -r src/components/calendar/grid/calendar-grid-header.jsx ../cloudcomp/lib/components/calendar/grid/calendar-grid-header.jsx
13,28c13,30
<           .map(dayIndex => (
<             <th
<               key={dayIndex}
<               scope='col'
<               className={clsx(
<                 styles['calendar-grid-cell'],
<                 styles['calendar-date-header']
<               )}>
<               <span aria-hidden='true'>
<                 {renderDayName(locale, dayIndex, 'short')}
<               </span>
<               <ScreenreaderOnly>
<                 {renderDayName(locale, dayIndex, 'long')}
<               </ScreenreaderOnly>
<             </th>
<           ))}
---
>           .map(
>             memo(dayIndex => (
>               <th
>                 key={dayIndex}
>                 scope='col'
>                 className={clsx(
>                   styles['calendar-grid-cell'],
>                   styles['calendar-date-header']
>                 )}>
>                 <span aria-hidden='true'>
>                   {renderDayName(locale, dayIndex, 'short')}
>                 </span>
>                 <ScreenreaderOnly>
>                   {renderDayName(locale, dayIndex, 'long')}
>                 </ScreenreaderOnly>
>               </th>
>             ))
>           )}
diff -r src/components/calendar/grid/index.jsx ../cloudcomp/lib/components/calendar/grid/index.jsx
41,88c41,94
<           {rows.map((row, rowIndex) => (
<             <tr key={rowIndex} className={styles['calendar-row']}>
<               {row.map((date, dateIndex) => {
<                 const isFocusable =
<                   !!focusableDate && isSameDate(date, focusableDate)
<                 const isSelected =
<                   !!selectedDate && isSameDate(date, selectedDate)
<                 const isEnabled = !isDateEnabled || isDateEnabled(date)
<                 const isCurrentDate = isSameDate(date, new Date())
<                 let tabIndex = void 0
<                 if (isFocusable && isEnabled) {
<                   tabIndex = 0
<                 } else if (isEnabled) {
<                   tabIndex = -1
<                 }
<                 return (
<                   <td
<                     key={`${rowIndex}:${dateIndex}`}
<                     ref={tabIndex === 0 ? focusedDateRef : void 0}
<                     tabIndex={tabIndex}
<                     aria-current={isCurrentDate ? 'date' : void 0}
<                     aria-selected={isEnabled ? isSelected : void 0}
<                     aria-disabled={!isEnabled}
<                     onClick={isEnabled ? () => onSelectDate(date) : void 0}
<                     className={clsx(
<                       styles['calendar-grid-cell'],
<                       styles['calendar-date'],
<                       {
<                         [styles['calendar-date-current-page']]:
<                           isCurrentPage(date),
<                         [styles['calendar-date-enabled']]: isEnabled,
<                         [styles['calendar-date-selected']]: isSelected,
<                         [styles['calendar-date-current']]: isCurrentDate,
<                         [styles['calendar-date-dense']]: denseGrid
<                       }
<                     )}>
<                     <span className={styles['date-inner']} aria-hidden='true'>
<                       {renderDate(date)}
<                     </span>
<                     {}
<                     <ScreenreaderOnly>
<                       {renderDateAnnouncement(date, isCurrentDate)}
<                     </ScreenreaderOnly>
<                   </td>
<                 )
<               })}
<             </tr>
<           ))}
---
>           {rows.map(
>             memo((row, rowIndex) => (
>               <tr key={rowIndex} className={styles['calendar-row']}>
>                 {row.map(
>                   memo((date, dateIndex) => {
>                     const isFocusable =
>                       !!focusableDate && isSameDate(date, focusableDate)
>                     const isSelected =
>                       !!selectedDate && isSameDate(date, selectedDate)
>                     const isEnabled = !isDateEnabled || isDateEnabled(date)
>                     const isCurrentDate = isSameDate(date, new Date())
>                     let tabIndex = void 0
>                     if (isFocusable && isEnabled) {
>                       tabIndex = 0
>                     } else if (isEnabled) {
>                       tabIndex = -1
>                     }
>                     return (
>                       <td
>                         key={`${rowIndex}:${dateIndex}`}
>                         ref={tabIndex === 0 ? focusedDateRef : void 0}
>                         tabIndex={tabIndex}
>                         aria-current={isCurrentDate ? 'date' : void 0}
>                         aria-selected={isEnabled ? isSelected : void 0}
>                         aria-disabled={!isEnabled}
>                         onClick={isEnabled ? () => onSelectDate(date) : void 0}
>                         className={clsx(
>                           styles['calendar-grid-cell'],
>                           styles['calendar-date'],
>                           {
>                             [styles['calendar-date-current-page']]:
>                               isCurrentPage(date),
>                             [styles['calendar-date-enabled']]: isEnabled,
>                             [styles['calendar-date-selected']]: isSelected,
>                             [styles['calendar-date-current']]: isCurrentDate,
>                             [styles['calendar-date-dense']]: denseGrid
>                           }
>                         )}>
>                         <span
>                           className={styles['date-inner']}
>                           aria-hidden='true'>
>                           {renderDate(date)}
>                         </span>
>                         {}
>                         <ScreenreaderOnly>
>                           {renderDateAnnouncement(date, isCurrentDate)}
>                         </ScreenreaderOnly>
>                       </td>
>                     )
>                   })
>                 )}
>               </tr>
>             ))
>           )}
diff -r src/components/cards/index.jsx ../cloudcomp/lib/components/cards/index.jsx
279,313c279,305
<         {items.map((item, index) => (
<           <li
<             className={clsx(styles.card, {
<               [styles['card-selectable']]: selectable,
<               [styles['card-selected']]: selectable && isItemSelected(item)
<             })}
<             key={getItemKey(trackBy, item, index)}
<             onFocus={onFocus}
<             {...(focusMarkers && focusMarkers.item)}
<             role={listItemRole}>
<             <div
<               className={clsx(
<                 styles['card-inner'],
<                 isRefresh && styles.refresh
<               )}
<               onClick={
<                 canClickEntireCard
<                   ? event => {
<                       getItemSelectionProps(item).onChange()
<                       event.currentTarget.querySelector('input')?.focus()
<                     }
<                   : void 0
<               }>
<               <div className={styles['card-header']}>
<                 <div className={styles['card-header-inner']}>
<                   {cardDefinition.header ? cardDefinition.header(item) : ''}
<                 </div>
<                 {selectable && (
<                   <div className={styles['selection-control']}>
<                     <SelectionControl
<                       onFocusDown={moveFocusDown}
<                       onFocusUp={moveFocusUp}
<                       onShiftToggle={updateShiftToggle}
<                       {...getItemSelectionProps(item)}
<                     />
---
>         {items.map(
>           memo((item, index) => (
>             <li
>               className={clsx(styles.card, {
>                 [styles['card-selectable']]: selectable,
>                 [styles['card-selected']]: selectable && isItemSelected(item)
>               })}
>               key={getItemKey(trackBy, item, index)}
>               onFocus={onFocus}
>               {...(focusMarkers && focusMarkers.item)}
>               role={listItemRole}>
>               <div
>                 className={clsx(
>                   styles['card-inner'],
>                   isRefresh && styles.refresh
>                 )}
>                 onClick={
>                   canClickEntireCard
>                     ? event => {
>                         getItemSelectionProps(item).onChange()
>                         event.currentTarget.querySelector('input')?.focus()
>                       }
>                     : void 0
>                 }>
>                 <div className={styles['card-header']}>
>                   <div className={styles['card-header-inner']}>
>                     {cardDefinition.header ? cardDefinition.header(item) : ''}
314a307,339
>                   {selectable && (
>                     <div className={styles['selection-control']}>
>                       <SelectionControl
>                         onFocusDown={moveFocusDown}
>                         onFocusUp={moveFocusUp}
>                         onShiftToggle={updateShiftToggle}
>                         {...getItemSelectionProps(item)}
>                       />
>                     </div>
>                   )}
>                 </div>
>                 {visibleSectionsDefinition.map(
>                   memo(({width = 100, header, content, id}, index2) => (
>                     <div
>                       key={id || index2}
>                       className={styles.section}
>                       style={{width: `${width}%`}}>
>                       {header ? (
>                         <div className={styles['section-header']}>
>                           {header}
>                         </div>
>                       ) : (
>                         ''
>                       )}
>                       {content ? (
>                         <div className={styles['section-content']}>
>                           {content(item)}
>                         </div>
>                       ) : (
>                         ''
>                       )}
>                     </div>
>                   ))
317,340c342,344
<               {visibleSectionsDefinition.map(
<                 ({width = 100, header, content, id}, index2) => (
<                   <div
<                     key={id || index2}
<                     className={styles.section}
<                     style={{width: `${width}%`}}>
<                     {header ? (
<                       <div className={styles['section-header']}>{header}</div>
<                     ) : (
<                       ''
<                     )}
<                     {content ? (
<                       <div className={styles['section-content']}>
<                         {content(item)}
<                       </div>
<                     ) : (
<                       ''
<                     )}
<                   </div>
<                 )
<               )}
<             </div>
<           </li>
<         ))}
---
>             </li>
>           ))
>         )}
diff -r src/components/checkbox/internal.jsx ../cloudcomp/lib/components/checkbox/internal.jsx
13,93c13,43
<   forwardRef(
<     (
<       {
<         controlId,
<         name,
<         checked,
<         disabled,
<         ariaRequired,
<         indeterminate,
<         children,
<         description,
<         ariaLabel,
<         onFocus,
<         onBlur,
<         onChange,
<         tabIndex: explicitTabIndex,
<         showOutline,
<         ariaControls,
<         __internalRootRef,
<         ...rest
<       },
<       ref
<     ) => {
<       const {ariaDescribedby, ariaLabelledby} = useFormFieldContext(rest)
<       const baseProps = getBaseProps(rest)
<       const checkboxRef = useRef(null)
<       useForwardFocus(ref, checkboxRef)
<       useEffect(() => {
<         if (checkboxRef.current) {
<           checkboxRef.current.indeterminate = Boolean(indeterminate)
<         }
<       })
<       const {tabIndex} = useSingleTabStopNavigation(checkboxRef, {
<         tabIndex: explicitTabIndex
<       })
<       return (
<         <AbstractSwitch
<           {...baseProps}
<           className={clsx(styles.root, baseProps.className)}
<           controlClassName={styles['checkbox-control']}
<           outlineClassName={styles.outline}
<           controlId={controlId}
<           disabled={disabled}
<           label={children}
<           description={description}
<           descriptionBottomPadding={true}
<           ariaLabel={ariaLabel}
<           ariaLabelledby={ariaLabelledby}
<           ariaDescribedby={ariaDescribedby}
<           ariaControls={ariaControls}
<           showOutline={showOutline}
<           nativeControl={nativeControlProps => (
<             <input
<               {...nativeControlProps}
<               ref={checkboxRef}
<               type='checkbox'
<               checked={checked}
<               name={name}
<               aria-required={ariaRequired ? 'true' : void 0}
<               tabIndex={tabIndex}
<               onFocus={() => fireNonCancelableEvent(onFocus)}
<               onBlur={() => fireNonCancelableEvent(onBlur)}
<               onChange={() => {}}
<             />
<           )}
<           onClick={() => {
<             checkboxRef.current?.focus()
<             fireNonCancelableEvent(
<               onChange,
< 
<               indeterminate
<                 ? {checked: true, indeterminate: false}
<                 : {checked: !checked, indeterminate: false}
<             )
<           }}
<           styledControl={
<             <CheckboxIcon
<               checked={checked}
<               indeterminate={indeterminate}
<               disabled={disabled}
<             />
---
>   memo(
>     forwardRef(
>       (
>         {
>           controlId,
>           name,
>           checked,
>           disabled,
>           ariaRequired,
>           indeterminate,
>           children,
>           description,
>           ariaLabel,
>           onFocus,
>           onBlur,
>           onChange,
>           tabIndex: explicitTabIndex,
>           showOutline,
>           ariaControls,
>           __internalRootRef,
>           ...rest
>         },
>         ref
>       ) => {
>         const {ariaDescribedby, ariaLabelledby} = useFormFieldContext(rest)
>         const baseProps = getBaseProps(rest)
>         const checkboxRef = useRef(null)
>         useForwardFocus(ref, checkboxRef)
>         useEffect(() => {
>           if (checkboxRef.current) {
>             checkboxRef.current.indeterminate = Boolean(indeterminate)
95,98c45,100
<           __internalRootRef={__internalRootRef}
<         />
<       )
<     }
---
>         })
>         const {tabIndex} = useSingleTabStopNavigation(checkboxRef, {
>           tabIndex: explicitTabIndex
>         })
>         return (
>           <AbstractSwitch
>             {...baseProps}
>             className={clsx(styles.root, baseProps.className)}
>             controlClassName={styles['checkbox-control']}
>             outlineClassName={styles.outline}
>             controlId={controlId}
>             disabled={disabled}
>             label={children}
>             description={description}
>             descriptionBottomPadding={true}
>             ariaLabel={ariaLabel}
>             ariaLabelledby={ariaLabelledby}
>             ariaDescribedby={ariaDescribedby}
>             ariaControls={ariaControls}
>             showOutline={showOutline}
>             nativeControl={nativeControlProps => (
>               <input
>                 {...nativeControlProps}
>                 ref={checkboxRef}
>                 type='checkbox'
>                 checked={checked}
>                 name={name}
>                 aria-required={ariaRequired ? 'true' : void 0}
>                 tabIndex={tabIndex}
>                 onFocus={() => fireNonCancelableEvent(onFocus)}
>                 onBlur={() => fireNonCancelableEvent(onBlur)}
>                 onChange={() => {}}
>               />
>             )}
>             onClick={() => {
>               checkboxRef.current?.focus()
>               fireNonCancelableEvent(
>                 onChange,
> 
>                 indeterminate
>                   ? {checked: true, indeterminate: false}
>                   : {checked: !checked, indeterminate: false}
>               )
>             }}
>             styledControl={
>               <CheckboxIcon
>                 checked={checked}
>                 indeterminate={indeterminate}
>                 disabled={disabled}
>               />
>             }
>             __internalRootRef={__internalRootRef}
>           />
>         )
>       }
>     )
diff -r src/components/column-layout/flexible-column-layout/index.jsx ../cloudcomp/lib/components/column-layout/flexible-column-layout/index.jsx
44,55c44,57
<         {flattenedChildren.map((child, i) => {
<           const key = child.key
<           return (
<             <div
<               key={key ? String(key) : void 0}
<               className={clsx(styles.item, {
<                 [styles['first-column']]: i % columnCount === 0
<               })}>
<               {child}
<             </div>
<           )
<         })}
---
>         {flattenedChildren.map(
>           memo((child, i) => {
>             const key = child.key
>             return (
>               <div
>                 key={key ? String(key) : void 0}
>                 className={clsx(styles.item, {
>                   [styles['first-column']]: i % columnCount === 0
>                 })}>
>                 {child}
>               </div>
>             )
>           })
>         )}
diff -r src/components/date-range-picker/calendar/grids/grid.jsx ../cloudcomp/lib/components/date-range-picker/calendar/grids/grid.jsx
53,65c53,67
<             {weekdays.map(dayIndex => (
<               <th
<                 key={dayIndex}
<                 scope='col'
<                 className={clsx(styles['grid-cell'], styles['day-header'])}>
<                 <span aria-hidden='true'>
<                   {renderDayName(locale, dayIndex, 'short')}
<                 </span>
<                 <ScreenreaderOnly>
<                   {renderDayName(locale, dayIndex, 'long')}
<                 </ScreenreaderOnly>
<               </th>
<             ))}
---
>             {weekdays.map(
>               memo(dayIndex => (
>                 <th
>                   key={dayIndex}
>                   scope='col'
>                   className={clsx(styles['grid-cell'], styles['day-header'])}>
>                   <span aria-hidden='true'>
>                     {renderDayName(locale, dayIndex, 'short')}
>                   </span>
>                   <ScreenreaderOnly>
>                     {renderDayName(locale, dayIndex, 'long')}
>                   </ScreenreaderOnly>
>                 </th>
>               ))
>             )}
69,153c71,97
<           {weeks.map((week, weekIndex) => {
<             return (
<               <tr key={weekIndex} className={styles.week}>
<                 {week.map((date, dateIndex) => {
<                   const isStartDate =
<                     !!selectedStartDate && isSameDay(date, selectedStartDate)
<                   const isEndDate =
<                     !!selectedEndDate && isSameDay(date, selectedEndDate)
<                   const isSelected = isStartDate || isEndDate
<                   const isRangeStartDate =
<                     !!rangeStartDate && isSameDay(date, rangeStartDate)
<                   const isRangeEndDate =
<                     !!rangeEndDate && isSameDay(date, rangeEndDate)
<                   const isFocused =
<                     !!focusedDate &&
<                     isSameDay(date, focusedDate) &&
<                     isSameMonth(date, baseDate)
<                   const dateIsInRange =
<                     isStartDate ||
<                     isEndDate ||
<                     isInRange(date, rangeStartDate, rangeEndDate)
<                   const inRangeStartWeek =
<                     rangeStartDate &&
<                     isInRange(
<                       date,
<                       rangeStartDate,
<                       addDays(addWeeks(rangeStartDate, 1), -1)
<                     )
<                   const inRangeEndWeek =
<                     rangeEndDate &&
<                     isInRange(
<                       date,
<                       rangeEndDate,
<                       addDays(addWeeks(rangeEndDate, -1), 1)
<                     )
<                   const onlyOneSelected =
<                     !!rangeStartDate && !!rangeEndDate
<                       ? isSameDay(rangeStartDate, rangeEndDate)
<                       : !selectedStartDate || !selectedEndDate
<                   const isEnabled = !isDateEnabled || isDateEnabled(date)
<                   const isFocusable = isFocused && isEnabled
<                   const baseClasses = {
<                     [styles.day]: true,
<                     [styles['grid-cell']]: true,
<                     [styles['in-first-row']]: weekIndex === 0,
<                     [styles['in-first-column']]: dateIndex === 0
<                   }
<                   if (!isSameMonth(date, baseDate)) {
<                     return (
<                       <td
<                         key={`${weekIndex}:${dateIndex}`}
<                         ref={isFocused ? focusedDateRef : void 0}
<                         className={clsx(baseClasses, {
<                           [styles['in-previous-month']]: isBefore(
<                             date,
<                             baseDate
<                           ),
<                           [styles['last-day-of-month']]:
<                             isLastDayOfMonth(date),
<                           [styles['in-next-month']]: isAfter(date, baseDate)
<                         })}
<                       />
<                     )
<                   }
<                   const handlers = {}
<                   if (isEnabled) {
<                     handlers.onClick = () => onSelectDate(date)
<                     handlers.onFocus = () => onFocusedDateChange(date)
<                   }
<                   let tabIndex = void 0
<                   if (isFocusable && isEnabled) {
<                     tabIndex = 0
<                   } else if (isEnabled) {
<                     tabIndex = -1
<                   }
<                   let dayAnnouncement = getDateLabel(locale, date, 'short')
<                   if (isToday(date)) {
<                     dayAnnouncement += '. ' + todayAriaLabel
<                   }
<                   return (
<                     <td
<                       ref={isFocused ? focusedDateRef : void 0}
<                       key={`${weekIndex}:${dateIndex}`}
<                       className={clsx(baseClasses, {
<                         [styles['in-current-month']]: isSameMonth(
---
>           {weeks.map(
>             memo((week, weekIndex) => {
>               return (
>                 <tr key={weekIndex} className={styles.week}>
>                   {week.map(
>                     memo((date, dateIndex) => {
>                       const isStartDate =
>                         !!selectedStartDate &&
>                         isSameDay(date, selectedStartDate)
>                       const isEndDate =
>                         !!selectedEndDate && isSameDay(date, selectedEndDate)
>                       const isSelected = isStartDate || isEndDate
>                       const isRangeStartDate =
>                         !!rangeStartDate && isSameDay(date, rangeStartDate)
>                       const isRangeEndDate =
>                         !!rangeEndDate && isSameDay(date, rangeEndDate)
>                       const isFocused =
>                         !!focusedDate &&
>                         isSameDay(date, focusedDate) &&
>                         isSameMonth(date, baseDate)
>                       const dateIsInRange =
>                         isStartDate ||
>                         isEndDate ||
>                         isInRange(date, rangeStartDate, rangeEndDate)
>                       const inRangeStartWeek =
>                         rangeStartDate &&
>                         isInRange(
155,181c99,154
<                           baseDate
<                         ),
<                         [styles.enabled]: isEnabled,
<                         [styles.selected]: isSelected,
<                         [styles['start-date']]: isStartDate,
<                         [styles['end-date']]: isEndDate,
<                         [styles['range-start-date']]: isRangeStartDate,
<                         [styles['range-end-date']]: isRangeEndDate,
<                         [styles['no-range']]: isSelected && onlyOneSelected,
<                         [styles['in-range']]: dateIsInRange,
<                         [styles['in-range-border-block-start']]:
<                           !!inRangeStartWeek || date.getDate() <= 7,
<                         [styles['in-range-border-block-end']]:
<                           !!inRangeEndWeek ||
<                           date.getDate() > getDaysInMonth(date) - 7,
<                         [styles['in-range-border-inline-start']]:
<                           dateIndex === 0 ||
<                           date.getDate() === 1 ||
<                           isRangeStartDate,
<                         [styles['in-range-border-inline-end']]:
<                           dateIndex === week.length - 1 ||
<                           isLastDayOfMonth(date) ||
<                           isRangeEndDate,
<                         [styles.today]: isToday(date)
<                       })}
<                       aria-selected={
<                         isEnabled ? isSelected || dateIsInRange : void 0
---
>                           rangeStartDate,
>                           addDays(addWeeks(rangeStartDate, 1), -1)
>                         )
>                       const inRangeEndWeek =
>                         rangeEndDate &&
>                         isInRange(
>                           date,
>                           rangeEndDate,
>                           addDays(addWeeks(rangeEndDate, -1), 1)
>                         )
>                       const onlyOneSelected =
>                         !!rangeStartDate && !!rangeEndDate
>                           ? isSameDay(rangeStartDate, rangeEndDate)
>                           : !selectedStartDate || !selectedEndDate
>                       const isEnabled = !isDateEnabled || isDateEnabled(date)
>                       const isFocusable = isFocused && isEnabled
>                       const baseClasses = {
>                         [styles.day]: true,
>                         [styles['grid-cell']]: true,
>                         [styles['in-first-row']]: weekIndex === 0,
>                         [styles['in-first-column']]: dateIndex === 0
>                       }
>                       if (!isSameMonth(date, baseDate)) {
>                         return (
>                           <td
>                             key={`${weekIndex}:${dateIndex}`}
>                             ref={isFocused ? focusedDateRef : void 0}
>                             className={clsx(baseClasses, {
>                               [styles['in-previous-month']]: isBefore(
>                                 date,
>                                 baseDate
>                               ),
>                               [styles['last-day-of-month']]:
>                                 isLastDayOfMonth(date),
>                               [styles['in-next-month']]: isAfter(
>                                 date,
>                                 baseDate
>                               )
>                             })}
>                           />
>                         )
>                       }
>                       const handlers = {}
>                       if (isEnabled) {
>                         handlers.onClick = () => onSelectDate(date)
>                         handlers.onFocus = () => onFocusedDateChange(date)
>                       }
>                       let tabIndex = void 0
>                       if (isFocusable && isEnabled) {
>                         tabIndex = 0
>                       } else if (isEnabled) {
>                         tabIndex = -1
>                       }
>                       let dayAnnouncement = getDateLabel(locale, date, 'short')
>                       if (isToday(date)) {
>                         dayAnnouncement += '. ' + todayAriaLabel
183,197c156,212
<                       aria-current={isToday(date) ? 'date' : void 0}
<                       data-date={formatDate(date)}
<                       aria-disabled={!isEnabled}
<                       tabIndex={tabIndex}
<                       {...handlers}>
<                       <span className={styles['day-inner']} aria-hidden='true'>
<                         {date.getDate()}
<                       </span>
<                       <ScreenreaderOnly>{dayAnnouncement}</ScreenreaderOnly>
<                     </td>
<                   )
<                 })}
<               </tr>
<             )
<           })}
---
>                       return (
>                         <td
>                           ref={isFocused ? focusedDateRef : void 0}
>                           key={`${weekIndex}:${dateIndex}`}
>                           className={clsx(baseClasses, {
>                             [styles['in-current-month']]: isSameMonth(
>                               date,
>                               baseDate
>                             ),
>                             [styles.enabled]: isEnabled,
>                             [styles.selected]: isSelected,
>                             [styles['start-date']]: isStartDate,
>                             [styles['end-date']]: isEndDate,
>                             [styles['range-start-date']]: isRangeStartDate,
>                             [styles['range-end-date']]: isRangeEndDate,
>                             [styles['no-range']]:
>                               isSelected && onlyOneSelected,
>                             [styles['in-range']]: dateIsInRange,
>                             [styles['in-range-border-block-start']]:
>                               !!inRangeStartWeek || date.getDate() <= 7,
>                             [styles['in-range-border-block-end']]:
>                               !!inRangeEndWeek ||
>                               date.getDate() > getDaysInMonth(date) - 7,
>                             [styles['in-range-border-inline-start']]:
>                               dateIndex === 0 ||
>                               date.getDate() === 1 ||
>                               isRangeStartDate,
>                             [styles['in-range-border-inline-end']]:
>                               dateIndex === week.length - 1 ||
>                               isLastDayOfMonth(date) ||
>                               isRangeEndDate,
>                             [styles.today]: isToday(date)
>                           })}
>                           aria-selected={
>                             isEnabled ? isSelected || dateIsInRange : void 0
>                           }
>                           aria-current={isToday(date) ? 'date' : void 0}
>                           data-date={formatDate(date)}
>                           aria-disabled={!isEnabled}
>                           tabIndex={tabIndex}
>                           {...handlers}>
>                           <span
>                             className={styles['day-inner']}
>                             aria-hidden='true'>
>                             {date.getDate()}
>                           </span>
>                           <ScreenreaderOnly>
>                             {dayAnnouncement}
>                           </ScreenreaderOnly>
>                         </td>
>                       )
>                     })
>                   )}
>                 </tr>
>               )
>             })
>           )}
diff -r src/components/date-range-picker/index.jsx ../cloudcomp/lib/components/date-range-picker/index.jsx
28,37c28,59
< const renderDateRange = ({
<   locale,
<   range,
<   placeholder = '',
<   formatRelativeRange,
<   absoluteFormat,
<   hideTimeOffset,
<   timeOffset
< }) => {
<   if (!range) {
---
> const renderDateRange = memo(
>   ({
>     locale,
>     range,
>     placeholder = '',
>     formatRelativeRange,
>     absoluteFormat,
>     hideTimeOffset,
>     timeOffset
>   }) => {
>     if (!range) {
>       return (
>         <span className={styles['label-text']} aria-disabled={true}>
>           {placeholder}
>         </span>
>       )
>     }
>     const formatted =
>       range.type === 'relative' ? (
>         formatRelativeRange?.(range) ?? ''
>       ) : (
>         <BreakSpaces
>           text={formatDateRange({
>             startDate: range.startDate,
>             endDate: range.endDate,
>             timeOffset,
>             hideTimeOffset,
>             format: absoluteFormat,
>             locale
>           })}
>         />
>       )
39,41c61,67
<       <span className={styles['label-text']} aria-disabled={true}>
<         {placeholder}
<       </span>
---
>       <InternalBox
>         fontWeight='normal'
>         display='inline'
>         color='inherit'
>         variant='span'>
>         {formatted}
>       </InternalBox>
44,68c70
<   const formatted =
<     range.type === 'relative' ? (
<       formatRelativeRange?.(range) ?? ''
<     ) : (
<       <BreakSpaces
<         text={formatDateRange({
<           startDate: range.startDate,
<           endDate: range.endDate,
<           timeOffset,
<           hideTimeOffset,
<           format: absoluteFormat,
<           locale
<         })}
<       />
<     )
<   return (
<     <InternalBox
<       fontWeight='normal'
<       display='inline'
<       color='inherit'
<       variant='span'>
<       {formatted}
<     </InternalBox>
<   )
< }
---
> )
74,83c76,87
<       {tokens.map((token, index) => (
<         <Fragment key={index}>
<           {token.length > 1 ? (
<             <span className={styles['label-token-nowrap']}>{token}</span>
<           ) : (
<             token
<           )}
<           {token === ' ' && <wbr />}
<         </Fragment>
<       ))}
---
>       {tokens.map(
>         memo((token, index) => (
>           <Fragment key={index}>
>             {token.length > 1 ? (
>               <span className={styles['label-token-nowrap']}>{token}</span>
>             ) : (
>               token
>             )}
>             {token === ' ' && <wbr />}
>           </Fragment>
>         ))
>       )}
diff -r src/components/file-upload/internal.jsx ../cloudcomp/lib/components/file-upload/internal.jsx
20,67c20,46
<   forwardRef(
<     (
<       {
<         accept,
<         ariaRequired,
<         multiple = false,
<         onChange,
<         value,
<         tokenLimit,
<         showFileSize,
<         showFileLastModified,
<         showFileThumbnail,
<         i18nStrings,
<         __internalRootRef = null,
<         constraintText,
<         errorText,
<         fileErrors,
<         ...restProps
<       },
<       externalRef
<     ) => {
<       const baseProps = getBaseProps(restProps)
<       const metadata = {
<         showFileSize,
<         showFileLastModified,
<         showFileThumbnail
<       }
<       const errorId = useUniqueId('error-')
<       const constraintTextId = useUniqueId('constraint-text-')
<       const fileInputRef = useRef(null)
<       const ref = useMergeRefs(fileInputRef, externalRef)
<       const [removedFileIndex, setRemovedFileIndex] = useState(null)
<       const handleFilesChange = newFiles => {
<         const newValue = multiple
<           ? [...value, ...newFiles]
<           : newFiles[0]
<             ? newFiles
<             : [...value]
<         fireNonCancelableEvent(onChange, {value: newValue})
<       }
<       const onFileRemove = removeFileIndex => {
<         const newValue = value.filter(
<           (_, fileIndex) => fileIndex !== removeFileIndex
<         )
<         fireNonCancelableEvent(onChange, {value: newValue})
<         setRemovedFileIndex(removeFileIndex)
<         if (value.length === 1) {
<           fileInputRef.current?.focus()
---
>   memo(
>     forwardRef(
>       (
>         {
>           accept,
>           ariaRequired,
>           multiple = false,
>           onChange,
>           value,
>           tokenLimit,
>           showFileSize,
>           showFileLastModified,
>           showFileThumbnail,
>           i18nStrings,
>           __internalRootRef = null,
>           constraintText,
>           errorText,
>           fileErrors,
>           ...restProps
>         },
>         externalRef
>       ) => {
>         const baseProps = getBaseProps(restProps)
>         const metadata = {
>           showFileSize,
>           showFileLastModified,
>           showFileThumbnail
69,138c48,88
<       }
<       const isDropzoneVisible = useDropzoneVisible(multiple)
<       const formFieldContext = useFormFieldContext(restProps)
<       const ariaDescribedBy = joinStrings(
<         restProps.ariaDescribedby ?? formFieldContext.ariaDescribedby,
<         errorText ? errorId : void 0,
<         constraintText ? constraintTextId : void 0
<       )
<       const hasError = Boolean(errorText || fileErrors?.filter(Boolean).length)
<       const invalid = restProps.invalid || formFieldContext.invalid || hasError
<       return (
<         <InternalSpaceBetween
<           {...baseProps}
<           size='xs'
<           className={clsx(baseProps.className, styles.root)}
<           __internalRootRef={__internalRootRef}>
<           <InternalBox>
<             {isDropzoneVisible ? (
<               <Dropzone onChange={handleFilesChange}>
<                 {i18nStrings.dropzoneText(multiple)}
<               </Dropzone>
<             ) : (
<               <FileInput
<                 ref={ref}
<                 accept={accept}
<                 ariaRequired={ariaRequired}
<                 multiple={multiple}
<                 onChange={handleFilesChange}
<                 value={value}
<                 {...restProps}
<                 ariaDescribedby={ariaDescribedBy}
<                 invalid={invalid}>
<                 {i18nStrings.uploadButtonText(multiple)}
<               </FileInput>
<             )}
<             {(constraintText || errorText) && (
<               <div className={styles.hints}>
<                 {errorText && (
<                   <FormFieldError
<                     id={errorId}
<                     errorIconAriaLabel={i18nStrings?.errorIconAriaLabel}>
<                     {errorText}
<                   </FormFieldError>
<                 )}
<                 {constraintText && (
<                   <ConstraintText id={constraintTextId} hasError={!!errorText}>
<                     {constraintText}
<                   </ConstraintText>
<                 )}
<               </div>
<             )}
<           </InternalBox>
<           {!multiple && value.length > 0 ? (
<             <InternalBox>
<               <Token
<                 ariaLabel={value[0].name}
<                 dismissLabel={i18nStrings.removeFileAriaLabel(0)}
<                 onDismiss={() => onFileRemove(0)}
<                 errorText={fileErrors?.[0]}
<                 errorIconAriaLabel={i18nStrings.errorIconAriaLabel}
<                 data-index={0}>
<                 <FileOption
<                   file={value[0]}
<                   metadata={metadata}
<                   i18nStrings={i18nStrings}
<                 />
<               </Token>
<             </InternalBox>
<           ) : null}
<           {multiple && value.length > 0 ? (
---
>         const errorId = useUniqueId('error-')
>         const constraintTextId = useUniqueId('constraint-text-')
>         const fileInputRef = useRef(null)
>         const ref = useMergeRefs(fileInputRef, externalRef)
>         const [removedFileIndex, setRemovedFileIndex] = useState(null)
>         const handleFilesChange = newFiles => {
>           const newValue = multiple
>             ? [...value, ...newFiles]
>             : newFiles[0]
>               ? newFiles
>               : [...value]
>           fireNonCancelableEvent(onChange, {value: newValue})
>         }
>         const onFileRemove = removeFileIndex => {
>           const newValue = value.filter(
>             (_, fileIndex) => fileIndex !== removeFileIndex
>           )
>           fireNonCancelableEvent(onChange, {value: newValue})
>           setRemovedFileIndex(removeFileIndex)
>           if (value.length === 1) {
>             fileInputRef.current?.focus()
>           }
>         }
>         const isDropzoneVisible = useDropzoneVisible(multiple)
>         const formFieldContext = useFormFieldContext(restProps)
>         const ariaDescribedBy = joinStrings(
>           restProps.ariaDescribedby ?? formFieldContext.ariaDescribedby,
>           errorText ? errorId : void 0,
>           constraintText ? constraintTextId : void 0
>         )
>         const hasError = Boolean(
>           errorText || fileErrors?.filter(Boolean).length
>         )
>         const invalid =
>           restProps.invalid || formFieldContext.invalid || hasError
>         return (
>           <InternalSpaceBetween
>             {...baseProps}
>             size='xs'
>             className={clsx(baseProps.className, styles.root)}
>             __internalRootRef={__internalRootRef}>
140,164c90,125
<               <TokenList
<                 alignment='vertical'
<                 items={value}
<                 renderItem={(file, fileIndex) => (
<                   <Token
<                     ariaLabel={file.name}
<                     dismissLabel={i18nStrings.removeFileAriaLabel(fileIndex)}
<                     onDismiss={() => onFileRemove(fileIndex)}
<                     errorText={fileErrors?.[fileIndex]}
<                     errorIconAriaLabel={i18nStrings.errorIconAriaLabel}
<                     data-index={fileIndex}>
<                     <FileOption
<                       file={file}
<                       metadata={metadata}
<                       i18nStrings={i18nStrings}
<                     />
<                   </Token>
<                 )}
<                 limit={tokenLimit}
<                 i18nStrings={{
<                   limitShowFewer: i18nStrings.limitShowFewer,
<                   limitShowMore: i18nStrings.limitShowMore
<                 }}
<                 moveFocusNextToIndex={removedFileIndex}
<               />
---
>               {isDropzoneVisible ? (
>                 <Dropzone onChange={handleFilesChange}>
>                   {i18nStrings.dropzoneText(multiple)}
>                 </Dropzone>
>               ) : (
>                 <FileInput
>                   ref={ref}
>                   accept={accept}
>                   ariaRequired={ariaRequired}
>                   multiple={multiple}
>                   onChange={handleFilesChange}
>                   value={value}
>                   {...restProps}
>                   ariaDescribedby={ariaDescribedBy}
>                   invalid={invalid}>
>                   {i18nStrings.uploadButtonText(multiple)}
>                 </FileInput>
>               )}
>               {(constraintText || errorText) && (
>                 <div className={styles.hints}>
>                   {errorText && (
>                     <FormFieldError
>                       id={errorId}
>                       errorIconAriaLabel={i18nStrings?.errorIconAriaLabel}>
>                       {errorText}
>                     </FormFieldError>
>                   )}
>                   {constraintText && (
>                     <ConstraintText
>                       id={constraintTextId}
>                       hasError={!!errorText}>
>                       {constraintText}
>                     </ConstraintText>
>                   )}
>                 </div>
>               )}
166,169c127,176
<           ) : null}
<         </InternalSpaceBetween>
<       )
<     }
---
>             {!multiple && value.length > 0 ? (
>               <InternalBox>
>                 <Token
>                   ariaLabel={value[0].name}
>                   dismissLabel={i18nStrings.removeFileAriaLabel(0)}
>                   onDismiss={() => onFileRemove(0)}
>                   errorText={fileErrors?.[0]}
>                   errorIconAriaLabel={i18nStrings.errorIconAriaLabel}
>                   data-index={0}>
>                   <FileOption
>                     file={value[0]}
>                     metadata={metadata}
>                     i18nStrings={i18nStrings}
>                   />
>                 </Token>
>               </InternalBox>
>             ) : null}
>             {multiple && value.length > 0 ? (
>               <InternalBox>
>                 <TokenList
>                   alignment='vertical'
>                   items={value}
>                   renderItem={(file, fileIndex) => (
>                     <Token
>                       ariaLabel={file.name}
>                       dismissLabel={i18nStrings.removeFileAriaLabel(fileIndex)}
>                       onDismiss={() => onFileRemove(fileIndex)}
>                       errorText={fileErrors?.[fileIndex]}
>                       errorIconAriaLabel={i18nStrings.errorIconAriaLabel}
>                       data-index={fileIndex}>
>                       <FileOption
>                         file={file}
>                         metadata={metadata}
>                         i18nStrings={i18nStrings}
>                       />
>                     </Token>
>                   )}
>                   limit={tokenLimit}
>                   i18nStrings={{
>                     limitShowFewer: i18nStrings.limitShowFewer,
>                     limitShowMore: i18nStrings.limitShowMore
>                   }}
>                   moveFocusNextToIndex={removedFileIndex}
>                 />
>               </InternalBox>
>             ) : null}
>           </InternalSpaceBetween>
>         )
>       }
>     )
diff -r src/components/flashbar/collapsible-flashbar.jsx ../cloudcomp/lib/components/flashbar/collapsible-flashbar.jsx
199c199
<   const renderList = () => (
---
>   const renderList = memo(() => (
220,247c220,229
<         {itemsToShow.map((item, index) => (
<           <Transition
<             key={getItemId(item)}
<             in={!hasLeft(item)}
<             onStatusChange={status => {
<               if (status === 'entered') {
<                 setEnteringItems([])
<               } else if (status === 'exited') {
<                 setExitingItems([])
<               }
<             }}>
<             {(state, transitionRootElement) => (
<               <li
<                 aria-hidden={!showInnerContent(item)}
<                 className={
<                   showInnerContent(item)
<                     ? clsx(
<                         styles['flash-list-item'],
<                         !isFlashbarStackExpanded && styles.item,
<                         !collapsedItemRefs.current[
<                           getAnimationElementId(item)
<                         ] && styles['expanded-only']
<                       )
<                     : clsx(
<                         styles.flash,
<                         styles[`flash-type-${item.type ?? 'info'}`],
<                         styles.item
<                       )
---
>         {itemsToShow.map(
>           memo((item, index) => (
>             <Transition
>               key={getItemId(item)}
>               in={!hasLeft(item)}
>               onStatusChange={status => {
>                 if (status === 'entered') {
>                   setEnteringItems([])
>                 } else if (status === 'exited') {
>                   setExitingItems([])
249,255c231,248
<                 ref={element => {
<                   if (isFlashbarStackExpanded) {
<                     expandedItemRefs.current[getAnimationElementId(item)] =
<                       element
<                   } else {
<                     collapsedItemRefs.current[getAnimationElementId(item)] =
<                       element
---
>               }}>
>               {memo((state, transitionRootElement) => (
>                 <li
>                   aria-hidden={!showInnerContent(item)}
>                   className={
>                     showInnerContent(item)
>                       ? clsx(
>                           styles['flash-list-item'],
>                           !isFlashbarStackExpanded && styles.item,
>                           !collapsedItemRefs.current[
>                             getAnimationElementId(item)
>                           ] && styles['expanded-only']
>                         )
>                       : clsx(
>                           styles.flash,
>                           styles[`flash-type-${item.type ?? 'info'}`],
>                           styles.item
>                         )
257,280c250,256
<                 }}
<                 style={
<                   !isFlashbarStackExpanded || transitioning
<                     ? {
<                         [customCssProps.flashbarStackIndex]:
<                           item.collapsedIndex ?? item.expandedIndex ?? index
<                       }
<                     : void 0
<                 }
<                 key={getItemId(item)}>
<                 {showInnerContent(item) && (
<                   <Flash
<                     className={clsx(
<                       animateFlash && styles['flash-with-motion'],
<                       isVisualRefresh && styles['flash-refresh']
<                     )}
<                     key={getItemId(item)}
<                     ref={
<                       shouldUseStandardAnimation(item, index)
<                         ? transitionRootElement
<                         : void 0
<                     }
<                     transitionState={
<                       shouldUseStandardAnimation(item, index) ? state : void 0
---
>                   ref={element => {
>                     if (isFlashbarStackExpanded) {
>                       expandedItemRefs.current[getAnimationElementId(item)] =
>                         element
>                     } else {
>                       collapsedItemRefs.current[getAnimationElementId(item)] =
>                         element
282,289c258,293
<                     i18nStrings={iconAriaLabels}
<                     {...item}
<                   />
<                 )}
<               </li>
<             )}
<           </Transition>
<         ))}
---
>                   }}
>                   style={
>                     !isFlashbarStackExpanded || transitioning
>                       ? {
>                           [customCssProps.flashbarStackIndex]:
>                             item.collapsedIndex ?? item.expandedIndex ?? index
>                         }
>                       : void 0
>                   }
>                   key={getItemId(item)}>
>                   {showInnerContent(item) && (
>                     <Flash
>                       className={clsx(
>                         animateFlash && styles['flash-with-motion'],
>                         isVisualRefresh && styles['flash-refresh']
>                       )}
>                       key={getItemId(item)}
>                       ref={
>                         shouldUseStandardAnimation(item, index)
>                           ? transitionRootElement
>                           : void 0
>                       }
>                       transitionState={
>                         shouldUseStandardAnimation(item, index)
>                           ? state
>                           : void 0
>                       }
>                       i18nStrings={iconAriaLabels}
>                       {...item}
>                     />
>                   )}
>                 </li>
>               ))}
>             </Transition>
>           ))
>         )}
292c296
<   )
---
>   ))
329,336c333,342
<               {counterTypes.map(({type, labelName, iconName}) => (
<                 <NotificationTypeCount
<                   key={type}
<                   iconName={iconName}
<                   label={iconAriaLabels[labelName]}
<                   count={countByType[type]}
<                 />
<               ))}
---
>               {counterTypes.map(
>                 memo(({type, labelName, iconName}) => (
>                   <NotificationTypeCount
>                     key={type}
>                     iconName={iconName}
>                     label={iconAriaLabels[labelName]}
>                     count={countByType[type]}
>                   />
>                 ))
>               )}
diff -r src/components/flashbar/flash.jsx ../cloudcomp/lib/components/flashbar/flash.jsx
25c25
< const dismissButton = (dismissLabel, onDismiss) => {
---
> const dismissButton = memo((dismissLabel, onDismiss) => {
38c38
< }
---
> })
diff -r src/components/flashbar/non-collapsible-flashbar.jsx ../cloudcomp/lib/components/flashbar/non-collapsible-flashbar.jsx
49c49
<   const renderFlatItemsWithTransitions = () => {
---
>   const renderFlatItemsWithTransitions = memo(() => {
58,76c58,78
<         {items.map((item, index) => (
<           <Transition
<             transitionChangeDelay={{
<               entering: TIMEOUT_FOR_ENTERING_ANIMATION
<             }}
<             key={item.id ?? index}
<             in={true}>
<             {(state, transitionRootElement) => (
<               <li className={styles['flash-list-item']}>
<                 {renderItem(
<                   item,
<                   item.id ?? index,
<                   transitionRootElement,
<                   state
<                 )}
<               </li>
<             )}
<           </Transition>
<         ))}
---
>         {items.map(
>           memo((item, index) => (
>             <Transition
>               transitionChangeDelay={{
>                 entering: TIMEOUT_FOR_ENTERING_ANIMATION
>               }}
>               key={item.id ?? index}
>               in={true}>
>               {memo((state, transitionRootElement) => (
>                 <li className={styles['flash-list-item']}>
>                   {renderItem(
>                     item,
>                     item.id ?? index,
>                     transitionRootElement,
>                     state
>                   )}
>                 </li>
>               ))}
>             </Transition>
>           ))
>         )}
79c81
<   }
---
>   })
81c83
<   const renderFlatItemsWithoutTransitions = () => {
---
>   const renderFlatItemsWithoutTransitions = memo(() => {
87,91c89,95
<         {items.map((item, index) => (
<           <li key={item.id ?? index} className={styles['flash-list-item']}>
<             {renderItem(item, item.id ?? index)}
<           </li>
<         ))}
---
>         {items.map(
>           memo((item, index) => (
>             <li key={item.id ?? index} className={styles['flash-list-item']}>
>               {renderItem(item, item.id ?? index)}
>             </li>
>           ))
>         )}
94c98
<   }
---
>   })
96,110c100,116
<   const renderItem = (item, key, transitionRootElement, transitionState) => {
<     return (
<       <Flash
<         className={clsx(
<           animateFlash && styles['flash-with-motion'],
<           isVisualRefresh && styles['flash-refresh']
<         )}
<         key={key}
<         ref={transitionRootElement}
<         transitionState={transitionState}
<         i18nStrings={iconAriaLabels}
<         {...item}
<       />
<     )
<   }
---
>   const renderItem = memo(
>     (item, key, transitionRootElement, transitionState) => {
>       return (
>         <Flash
>           className={clsx(
>             animateFlash && styles['flash-with-motion'],
>             isVisualRefresh && styles['flash-refresh']
>           )}
>           key={key}
>           ref={transitionRootElement}
>           transitionState={transitionState}
>           i18nStrings={iconAriaLabels}
>           {...item}
>         />
>       )
>     }
>   )
diff -r src/components/grid/internal.jsx ../cloudcomp/lib/components/grid/internal.jsx
44,75c44,79
<           {flattenedChildren.map((child, i) => {
<             const key = child.key
<             return (
<               <div
<                 key={key ? String(key) : void 0}
<                 className={clsx(
<                   styles['grid-column'],
<                   getColumnClassNames(
<                     'colspan',
<                     gridDefinition[i]?.colspan,
<                     defaultBreakpoint
<                   ),
<                   getColumnClassNames(
<                     'offset',
<                     gridDefinition[i]?.offset,
<                     defaultBreakpoint
<                   ),
<                   getColumnClassNames(
<                     'pull',
<                     gridDefinition[i]?.pull,
<                     defaultBreakpoint
<                   ),
<                   getColumnClassNames(
<                     'push',
<                     gridDefinition[i]?.push,
<                     defaultBreakpoint
<                   )
<                 )}>
<                 <div className={styles['restore-pointer-events']}>{child}</div>
<               </div>
<             )
<           })}
---
>           {memo(
>             flattenedChildren.map((child, i) => {
>               const key = child.key
>               return (
>                 <div
>                   key={key ? String(key) : void 0}
>                   className={clsx(
>                     styles['grid-column'],
>                     getColumnClassNames(
>                       'colspan',
>                       gridDefinition[i]?.colspan,
>                       defaultBreakpoint
>                     ),
>                     getColumnClassNames(
>                       'offset',
>                       gridDefinition[i]?.offset,
>                       defaultBreakpoint
>                     ),
>                     getColumnClassNames(
>                       'pull',
>                       gridDefinition[i]?.pull,
>                       defaultBreakpoint
>                     ),
>                     getColumnClassNames(
>                       'push',
>                       gridDefinition[i]?.push,
>                       defaultBreakpoint
>                     )
>                   )}>
>                   <div className={styles['restore-pointer-events']}>
>                     {child}
>                   </div>
>                 </div>
>               )
>             })
>           )}
Only in ../cloudcomp/lib/components: index.js
diff -r src/components/internal/components/cartesian-chart/bottom-labels.jsx ../cloudcomp/lib/components/internal/components/cartesian-chart/bottom-labels.jsx
83,114c83,120
<           ({position, lines}, index) =>
<             isFinite(position) && (
<               <g
<                 key={index}
<                 transform={`translate(${position + xOffset},0)`}
<                 className={clsx(styles.ticks, styles['ticks--bottom'], {
<                   [styles['ticks--x']]: axis === 'x',
<                   [styles['ticks--y']]: axis === 'y'
<                 })}
<                 role='listitem'
<                 aria-label={lines.join('\n')}>
<                 <line
<                   className={styles.ticks__line}
<                   x1={0}
<                   x2={0}
<                   y1={0}
<                   y2={TICK_LENGTH}
<                   aria-hidden='true'
<                 />
<                 {lines.map((line, lineIndex) => (
<                   <text
<                     className={styles.ticks__text}
<                     key={lineIndex}
<                     x={0}
<                     y={
<                       TICK_LENGTH + TICK_MARGIN + lineIndex * TICK_LINE_HEIGHT
<                     }>
<                     {line}
<                   </text>
<                 ))}
<               </g>
<             )
---
>           memo(
>             ({position, lines}, index) =>
>               isFinite(position) && (
>                 <g
>                   key={index}
>                   transform={`translate(${position + xOffset},0)`}
>                   className={clsx(styles.ticks, styles['ticks--bottom'], {
>                     [styles['ticks--x']]: axis === 'x',
>                     [styles['ticks--y']]: axis === 'y'
>                   })}
>                   role='listitem'
>                   aria-label={lines.join('\n')}>
>                   <line
>                     className={styles.ticks__line}
>                     x1={0}
>                     x2={0}
>                     y1={0}
>                     y2={TICK_LENGTH}
>                     aria-hidden='true'
>                   />
>                   {lines.map(
>                     memo((line, lineIndex) => (
>                       <text
>                         className={styles.ticks__text}
>                         key={lineIndex}
>                         x={0}
>                         y={
>                           TICK_LENGTH +
>                           TICK_MARGIN +
>                           lineIndex * TICK_LINE_HEIGHT
>                         }>
>                         {line}
>                       </text>
>                     ))
>                   )}
>                 </g>
>               )
>           )
diff -r src/components/internal/components/cartesian-chart/labels-measure.jsx ../cloudcomp/lib/components/internal/components/cartesian-chart/labels-measure.jsx
12c12
<     const labelMapper = value => {
---
>     const labelMapper = memo(value => {
23,30c23,32
<           {lines.map((line, lineIndex) => (
<             <div
<               key={lineIndex}
<               className={styles['labels-left__label']}
<               aria-hidden='true'>
<               {line}
<             </div>
<           ))}
---
>           {lines.map(
>             memo((line, lineIndex) => (
>               <div
>                 key={lineIndex}
>                 className={styles['labels-left__label']}
>                 aria-hidden='true'>
>                 {line}
>               </div>
>             ))
>           )}
33c35
<     }
---
>     })
diff -r src/components/internal/components/cartesian-chart/left-labels.jsx ../cloudcomp/lib/components/internal/components/cartesian-chart/left-labels.jsx
63,97c63,81
<           ({position, lines}, index) =>
<             isFinite(position) && (
<               <g
<                 key={index}
<                 role='listitem'
<                 transform={`translate(0,${position + yOffset})`}
<                 className={clsx(
<                   styles.ticks,
<                   axis === 'x' ? styles['ticks--x'] : styles['ticks--y']
<                 )}>
<                 {axis === 'y' && (
<                   <line
<                     className={clsx(styles.grid, styles.ticks_line)}
<                     x1={-TICK_LENGTH}
<                     y1={0}
<                     x2={plotWidth}
<                     y2={0}
<                     aria-hidden='true'
<                   />
<                 )}
<                 {lines.map((line, lineIndex) => {
<                   const lineTextProps = {
<                     x: -(TICK_LENGTH + TICK_MARGIN),
<                     y:
<                       (lineIndex - (lines.length - 1) * 0.5) *
<                       TICK_LINE_HEIGHT,
<                     className: styles.ticks__text,
<                     children: line
<                   }
<                   return (labelToBoxCache.current[lines[0]]?.width ?? 0) >
<                     maxLabelsWidth ? (
<                     <ResponsiveText
<                       key={lineIndex}
<                       {...lineTextProps}
<                       maxWidth={maxLabelsWidth}
---
>           memo(
>             ({position, lines}, index) =>
>               isFinite(position) && (
>                 <g
>                   key={index}
>                   role='listitem'
>                   transform={`translate(0,${position + yOffset})`}
>                   className={clsx(
>                     styles.ticks,
>                     axis === 'x' ? styles['ticks--x'] : styles['ticks--y']
>                   )}>
>                   {axis === 'y' && (
>                     <line
>                       className={clsx(styles.grid, styles.ticks_line)}
>                       x1={-TICK_LENGTH}
>                       y1={0}
>                       x2={plotWidth}
>                       y2={0}
>                       aria-hidden='true'
99,104c83,108
<                   ) : (
<                     <text key={lineIndex} {...lineTextProps} />
<                   )
<                 })}
<               </g>
<             )
---
>                   )}
>                   {lines.map(
>                     memo((line, lineIndex) => {
>                       const lineTextProps = {
>                         x: -(TICK_LENGTH + TICK_MARGIN),
>                         y:
>                           (lineIndex - (lines.length - 1) * 0.5) *
>                           TICK_LINE_HEIGHT,
>                         className: styles.ticks__text,
>                         children: line
>                       }
>                       return (labelToBoxCache.current[lines[0]]?.width ?? 0) >
>                         maxLabelsWidth ? (
>                         <ResponsiveText
>                           key={lineIndex}
>                           {...lineTextProps}
>                           maxWidth={maxLabelsWidth}
>                         />
>                       ) : (
>                         <text key={lineIndex} {...lineTextProps} />
>                       )
>                     })
>                   )}
>                 </g>
>               )
>           )
diff -r src/components/internal/components/cartesian-chart/vertical-grid-lines.jsx ../cloudcomp/lib/components/internal/components/cartesian-chart/vertical-grid-lines.jsx
7,18c7,20
<       {ticks.map(tick => {
<         const x = scale.d3Scale(tick) ?? NaN
<         return (
<           isFinite(x) && (
<             <line
<               key={tick}
<               className={styles.grid}
<               x1={x}
<               y1={0}
<               x2={x}
<               y2={height}
<             />
---
>       {ticks.map(
>         memo(tick => {
>           const x = scale.d3Scale(tick) ?? NaN
>           return (
>             isFinite(x) && (
>               <line
>                 key={tick}
>                 className={styles.grid}
>                 x1={x}
>                 y1={0}
>                 x2={x}
>                 y2={height}
>               />
>             )
20,21c22,23
<         )
<       })}
---
>         })
>       )}
diff -r src/components/internal/components/cartesian-chart/vertical-marker.jsx ../cloudcomp/lib/components/internal/components/cartesian-chart/vertical-marker.jsx
21,31c21,33
<           points.map(point => (
<             <circle
<               key={point.key}
<               aria-hidden='true'
<               className={styles['vertical-marker-circle']}
<               cx={point.x}
<               cy={point.y}
<               r={4}
<               stroke={point.color}
<             />
<           ))}
---
>           memo(
>             points.map(point => (
>               <circle
>                 key={point.key}
>                 aria-hidden='true'
>                 className={styles['vertical-marker-circle']}
>                 cx={point.x}
>                 cy={point.y}
>                 r={4}
>                 stroke={point.color}
>               />
>             ))
>           )}
diff -r src/components/internal/components/chart-filter/index.jsx ../cloudcomp/lib/components/internal/components/chart-filter/index.jsx
15,24c15,26
<     const defaultOptions = series.map((d, i) => ({
<       label: d.label,
<       value: '' + i,
<       datum: d.datum,
<       __customIcon: (
<         <span className={styles['custom-icon-wrapper']}>
<           <SeriesMarker color={d.color} type={d.type} />
<         </span>
<       )
<     }))
---
>     const defaultOptions = series.map(
>       memo((d, i) => ({
>         label: d.label,
>         value: '' + i,
>         datum: d.datum,
>         __customIcon: (
>           <span className={styles['custom-icon-wrapper']}>
>             <SeriesMarker color={d.color} type={d.type} />
>           </span>
>         )
>       }))
>     )
diff -r src/components/internal/components/chart-legend/index.jsx ../cloudcomp/lib/components/internal/components/chart-legend/index.jsx
86,103c86,111
<             {series.map((s, index) => {
<               const someHighlighted = highlightedSeries !== null
<               const isHighlighted = highlightedSeries === s.datum
<               const isDimmed = someHighlighted && !isHighlighted
<               return (
<                 <div
<                   role='button'
<                   key={index}
<                   aria-pressed={isHighlighted}
<                   className={clsx(styles.marker, {
<                     [styles['marker--dimmed']]: isDimmed,
<                     [styles['marker--highlighted']]: isHighlighted
<                   })}
<                   ref={elem => {
<                     if (elem) {
<                       segmentsRef.current[index] = elem
<                     } else {
<                       delete segmentsRef.current[index]
---
>             {series.map(
>               memo((s, index) => {
>                 const someHighlighted = highlightedSeries !== null
>                 const isHighlighted = highlightedSeries === s.datum
>                 const isDimmed = someHighlighted && !isHighlighted
>                 return (
>                   <div
>                     role='button'
>                     key={index}
>                     aria-pressed={isHighlighted}
>                     className={clsx(styles.marker, {
>                       [styles['marker--dimmed']]: isDimmed,
>                       [styles['marker--highlighted']]: isHighlighted
>                     })}
>                     ref={elem => {
>                       if (elem) {
>                         segmentsRef.current[index] = elem
>                       } else {
>                         delete segmentsRef.current[index]
>                       }
>                     }}
>                     tabIndex={
>                       index === highlightedSeriesIndex ||
>                       (highlightedSeriesIndex === void 0 && index === 0)
>                         ? 0
>                         : -1
105,119c113,121
<                   }}
<                   tabIndex={
<                     index === highlightedSeriesIndex ||
<                     (highlightedSeriesIndex === void 0 && index === 0)
<                       ? 0
<                       : -1
<                   }
<                   onFocus={() => handleSelection(index)}
<                   onClick={() => handleSelection(index)}
<                   onMouseOver={() => handleMouseOver(s.datum)}
<                   onMouseLeave={handleMouseLeave}>
<                   <SeriesMarker color={s.color} type={s.type} /> {s.label}
<                 </div>
<               )
<             })}
---
>                     onFocus={() => handleSelection(index)}
>                     onClick={() => handleSelection(index)}
>                     onMouseOver={() => handleMouseOver(s.datum)}
>                     onMouseLeave={handleMouseLeave}>
>                     <SeriesMarker color={s.color} type={s.type} /> {s.label}
>                   </div>
>                 )
>               })
>             )}
diff -r src/components/internal/components/chart-popover/index.jsx ../cloudcomp/lib/components/internal/components/chart-popover/index.jsx
13,44c13,46
<   forwardRef(
<     (
<       {
<         position = 'right',
<         size = 'medium',
<         fixedWidth = false,
<         dismissButton = false,
<         dismissAriaLabel,
<         children,
<         title,
<         trackRef,
<         trackKey,
<         onDismiss,
<         container,
<         onMouseEnter,
<         onMouseLeave,
<         onBlur,
<         ...restProps
<       },
<       ref
<     ) => {
<       const baseProps = getBaseProps(restProps)
<       const popoverObjectRef = useRef(null)
<       const popoverRef = useMergeRefs(popoverObjectRef, ref)
<       useEffect(() => {
<         const onDocumentClick = event => {
<           if (
<             event.target &&
<             !nodeBelongs(popoverObjectRef.current, event.target) &&
<             !nodeContains(container, event.target)
<           ) {
<             onDismiss(true)
---
>   memo(
>     forwardRef(
>       (
>         {
>           position = 'right',
>           size = 'medium',
>           fixedWidth = false,
>           dismissButton = false,
>           dismissAriaLabel,
>           children,
>           title,
>           trackRef,
>           trackKey,
>           onDismiss,
>           container,
>           onMouseEnter,
>           onMouseLeave,
>           onBlur,
>           ...restProps
>         },
>         ref
>       ) => {
>         const baseProps = getBaseProps(restProps)
>         const popoverObjectRef = useRef(null)
>         const popoverRef = useMergeRefs(popoverObjectRef, ref)
>         useEffect(() => {
>           const onDocumentClick = event => {
>             if (
>               event.target &&
>               !nodeBelongs(popoverObjectRef.current, event.target) &&
>               !nodeContains(container, event.target)
>             ) {
>               onDismiss(true)
>             }
46,51c48
<         }
<         document.addEventListener('mousedown', onDocumentClick, {
<           capture: true
<         })
<         return () => {
<           document.removeEventListener('mousedown', onDocumentClick, {
---
>           document.addEventListener('mousedown', onDocumentClick, {
54,84c51,64
<         }
<       }, [container, onDismiss])
<       const isPinned = dismissButton
<       return (
<         <div
<           {...baseProps}
<           className={clsx(
<             popoverStyles.root,
<             styles.root,
<             baseProps.className
<           )}
<           ref={popoverRef}
<           onMouseEnter={onMouseEnter}
<           onMouseLeave={onMouseLeave}
<           onBlur={onBlur}
<           tabIndex={-1}>
<           <PopoverContainer
<             size={size}
<             fixedWidth={fixedWidth}
<             position={position}
<             trackRef={trackRef}
<             trackKey={trackKey}
<             arrow={position2 => (
<               <div
<                 className={clsx(
<                   popoverStyles.arrow,
<                   popoverStyles[`arrow-position-${position2}`]
<                 )}>
<                 <div className={popoverStyles['arrow-outer']} />
<                 <div className={popoverStyles['arrow-inner']} />
<               </div>
---
>           return () => {
>             document.removeEventListener('mousedown', onDocumentClick, {
>               capture: true
>             })
>           }
>         }, [container, onDismiss])
>         const isPinned = dismissButton
>         return (
>           <div
>             {...baseProps}
>             className={clsx(
>               popoverStyles.root,
>               styles.root,
>               baseProps.className
86,103c66,105
<             keepPosition={true}
<             allowVerticalOverflow={true}
<             allowScrollToFit={isPinned}>
<             <div className={styles['hover-area']}>
<               <PopoverBody
<                 dismissButton={dismissButton}
<                 dismissAriaLabel={dismissAriaLabel}
<                 header={title}
<                 onDismiss={onDismiss}
<                 overflowVisible='content'
<                 className={styles['popover-body']}>
<                 {children}
<               </PopoverBody>
<             </div>
<           </PopoverContainer>
<         </div>
<       )
<     }
---
>             ref={popoverRef}
>             onMouseEnter={onMouseEnter}
>             onMouseLeave={onMouseLeave}
>             onBlur={onBlur}
>             tabIndex={-1}>
>             <PopoverContainer
>               size={size}
>               fixedWidth={fixedWidth}
>               position={position}
>               trackRef={trackRef}
>               trackKey={trackKey}
>               arrow={position2 => (
>                 <div
>                   className={clsx(
>                     popoverStyles.arrow,
>                     popoverStyles[`arrow-position-${position2}`]
>                   )}>
>                   <div className={popoverStyles['arrow-outer']} />
>                   <div className={popoverStyles['arrow-inner']} />
>                 </div>
>               )}
>               keepPosition={true}
>               allowVerticalOverflow={true}
>               allowScrollToFit={isPinned}>
>               <div className={styles['hover-area']}>
>                 <PopoverBody
>                   dismissButton={dismissButton}
>                   dismissAriaLabel={dismissAriaLabel}
>                   header={title}
>                   onDismiss={onDismiss}
>                   overflowVisible='content'
>                   className={styles['popover-body']}>
>                   {children}
>                 </PopoverBody>
>               </div>
>             </PopoverContainer>
>           </div>
>         )
>       }
>     )
diff -r src/components/internal/components/chart-series-details/index.jsx ../cloudcomp/lib/components/internal/components/chart-series-details/index.jsx
42,85c42,87
<             {details.map(
<               (
<                 {
<                   key,
<                   value,
<                   markerType,
<                   color,
<                   isDimmed,
<                   subItems,
<                   expandableId
<                 },
<                 index
<               ) => (
<                 <li
<                   key={index}
<                   className={clsx({
<                     [styles.dimmed]: isDimmed,
<                     [styles['list-item']]: true,
<                     [styles['with-sub-items']]: subItems?.length,
<                     [styles.expandable]: !!expandableId
<                   })}>
<                   {subItems?.length && !!expandableId ? (
<                     <ExpandableSeries
<                       itemKey={key}
<                       value={value}
<                       markerType={markerType}
<                       color={color}
<                       subItems={subItems}
<                       expanded={isExpanded(expandableId)}
<                       setExpandedState={state =>
<                         setExpandedState &&
<                         setExpandedState(expandableId, state)
<                       }
<                     />
<                   ) : (
<                     <NonExpandableSeries
<                       itemKey={key}
<                       value={value}
<                       markerType={markerType}
<                       color={color}
<                       subItems={subItems}
<                     />
<                   )}
<                 </li>
---
>             {memo(
>               details.map(
>                 (
>                   {
>                     key,
>                     value,
>                     markerType,
>                     color,
>                     isDimmed,
>                     subItems,
>                     expandableId
>                   },
>                   index
>                 ) => (
>                   <li
>                     key={index}
>                     className={clsx({
>                       [styles.dimmed]: isDimmed,
>                       [styles['list-item']]: true,
>                       [styles['with-sub-items']]: subItems?.length,
>                       [styles.expandable]: !!expandableId
>                     })}>
>                     {subItems?.length && !!expandableId ? (
>                       <ExpandableSeries
>                         itemKey={key}
>                         value={value}
>                         markerType={markerType}
>                         color={color}
>                         subItems={subItems}
>                         expanded={isExpanded(expandableId)}
>                         setExpandedState={state =>
>                           setExpandedState &&
>                           setExpandedState(expandableId, state)
>                         }
>                       />
>                     ) : (
>                       <NonExpandableSeries
>                         itemKey={key}
>                         value={value}
>                         markerType={markerType}
>                         color={color}
>                         subItems={subItems}
>                       />
>                     )}
>                   </li>
>                 )
98,109c100,113
<       {items.map(({key, value}, index) => (
<         <li
<           key={index}
<           className={clsx(
<             styles['inner-list-item'],
<             styles['key-value-pair'],
<             (expanded || !expandable) && styles.announced
<           )}>
<           <span className={styles.key}>{key}</span>
<           <span className={styles.value}>{value}</span>
<         </li>
<       ))}
---
>       {items.map(
>         memo(({key, value}, index) => (
>           <li
>             key={index}
>             className={clsx(
>               styles['inner-list-item'],
>               styles['key-value-pair'],
>               (expanded || !expandable) && styles.announced
>             )}>
>             <span className={styles.key}>{key}</span>
>             <span className={styles.value}>{value}</span>
>           </li>
>         ))
>       )}
diff -r src/components/internal/components/chart-status-container/index.jsx ../cloudcomp/lib/components/internal/components/chart-status-container/index.jsx
28,72c28,77
<     const statusContainer = useMemo(() => {
<       const handleRecoveryClick = event => {
<         event.preventDefault()
<         fireNonCancelableEvent(onRecoveryClick)
<       }
<       if (statusType === 'error') {
<         const renderedRecoveryText = i18n('recoveryText', recoveryText)
<         return (
<           <span>
<             <InternalStatusIndicator type='error'>
<               {i18n('errorText', errorText)}
<             </InternalStatusIndicator>{' '}
<             {!!renderedRecoveryText && !!onRecoveryClick && (
<               <InternalLink onFollow={handleRecoveryClick} variant='recovery'>
<                 {renderedRecoveryText}
<               </InternalLink>
<             )}
<           </span>
<         )
<       }
<       if (statusType === 'loading') {
<         return (
<           <InternalStatusIndicator type='loading'>
<             {i18n('loadingText', loadingText)}
<           </InternalStatusIndicator>
<         )
<       }
<       if (isNoMatch) {
<         return <div className={styles.empty}>{noMatch}</div>
<       }
<       if (isEmpty) {
<         return <div className={styles.empty}>{empty}</div>
<       }
<     }, [
<       i18n,
<       statusType,
<       onRecoveryClick,
<       isEmpty,
<       isNoMatch,
<       recoveryText,
<       loadingText,
<       errorText,
<       empty,
<       noMatch
<     ])
---
>     const statusContainer = useMemo(
>       memo(() => {
>         const handleRecoveryClick = event => {
>           event.preventDefault()
>           fireNonCancelableEvent(onRecoveryClick)
>         }
>         if (statusType === 'error') {
>           const renderedRecoveryText = i18n('recoveryText', recoveryText)
>           return (
>             <span>
>               <InternalStatusIndicator type='error'>
>                 {i18n('errorText', errorText)}
>               </InternalStatusIndicator>{' '}
>               {!!renderedRecoveryText && !!onRecoveryClick && (
>                 <InternalLink
>                   onFollow={handleRecoveryClick}
>                   variant='recovery'>
>                   {renderedRecoveryText}
>                 </InternalLink>
>               )}
>             </span>
>           )
>         }
>         if (statusType === 'loading') {
>           return (
>             <InternalStatusIndicator type='loading'>
>               {i18n('loadingText', loadingText)}
>             </InternalStatusIndicator>
>           )
>         }
>         if (isNoMatch) {
>           return <div className={styles.empty}>{noMatch}</div>
>         }
>         if (isEmpty) {
>           return <div className={styles.empty}>{empty}</div>
>         }
>       }),
>       [
>         i18n,
>         statusType,
>         onRecoveryClick,
>         isEmpty,
>         isNoMatch,
>         recoveryText,
>         loadingText,
>         errorText,
>         empty,
>         noMatch
>       ]
>     )
diff -r src/components/internal/components/dropdown/index.jsx ../cloudcomp/lib/components/internal/components/dropdown/index.jsx
390c390
<             {(state, ref) => (
---
>             {memo((state, ref) => (
429c429
<             )}
---
>             ))}
diff -r src/components/internal/components/dropdown-status/index.jsx ../cloudcomp/lib/components/internal/components/dropdown-status/index.jsx
12,64c12,67
< const useDropdownStatus = ({
<   statusType,
<   empty,
<   loadingText,
<   finishedText,
<   filteringResultsText,
<   errorText,
<   recoveryText,
<   isEmpty,
<   isNoMatch,
<   isFiltered,
<   noMatch,
<   onRecoveryClick,
<   hasRecoveryCallback = false,
<   errorIconAriaLabel
< }) => {
<   const previousStatusType = usePrevious(statusType)
<   const statusResult = {isSticky: true, content: null}
<   if (statusType === 'loading') {
<     statusResult.content = (
<       <InternalStatusIndicator type={'loading'}>
<         {loadingText}
<       </InternalStatusIndicator>
<     )
<   } else if (statusType === 'error') {
<     statusResult.content = (
<       <span>
<         <InternalStatusIndicator
<           type='error'
<           __display='inline'
<           __animate={previousStatusType !== 'error'}
<           iconAriaLabel={errorIconAriaLabel}>
<           {errorText}
<         </InternalStatusIndicator>{' '}
<         {!!recoveryText && hasRecoveryCallback && (
<           <InternalLink
<             onFollow={() => fireNonCancelableEvent(onRecoveryClick)}
<             variant='recovery'
<             className={styles.recovery}>
<             {recoveryText}
<           </InternalLink>
<         )}
<       </span>
<     )
<   } else if (isEmpty && empty) {
<     statusResult.content = empty
<   } else if (isNoMatch && noMatch) {
<     statusResult.content = noMatch
<   } else if (isFiltered && filteringResultsText) {
<     statusResult.content = filteringResultsText
<   } else if (statusType === 'finished' && finishedText) {
<     statusResult.content = finishedText
<     statusResult.isSticky = false
---
> const useDropdownStatus = memo(
>   ({
>     statusType,
>     empty,
>     loadingText,
>     finishedText,
>     filteringResultsText,
>     errorText,
>     recoveryText,
>     isEmpty,
>     isNoMatch,
>     isFiltered,
>     noMatch,
>     onRecoveryClick,
>     hasRecoveryCallback = false,
>     errorIconAriaLabel
>   }) => {
>     const previousStatusType = usePrevious(statusType)
>     const statusResult = {isSticky: true, content: null}
>     if (statusType === 'loading') {
>       statusResult.content = (
>         <InternalStatusIndicator type={'loading'}>
>           {loadingText}
>         </InternalStatusIndicator>
>       )
>     } else if (statusType === 'error') {
>       statusResult.content = (
>         <span>
>           <InternalStatusIndicator
>             type='error'
>             __display='inline'
>             __animate={previousStatusType !== 'error'}
>             iconAriaLabel={errorIconAriaLabel}>
>             {errorText}
>           </InternalStatusIndicator>{' '}
>           {!!recoveryText && hasRecoveryCallback && (
>             <InternalLink
>               onFollow={() => fireNonCancelableEvent(onRecoveryClick)}
>               variant='recovery'
>               className={styles.recovery}>
>               {recoveryText}
>             </InternalLink>
>           )}
>         </span>
>       )
>     } else if (isEmpty && empty) {
>       statusResult.content = empty
>     } else if (isNoMatch && noMatch) {
>       statusResult.content = noMatch
>     } else if (isFiltered && filteringResultsText) {
>       statusResult.content = filteringResultsText
>     } else if (statusType === 'finished' && finishedText) {
>       statusResult.content = finishedText
>       statusResult.isSticky = false
>     }
>     return statusResult
66,67c69
<   return statusResult
< }
---
> )
diff -r src/components/internal/components/menu-dropdown/index.jsx ../cloudcomp/lib/components/internal/components/menu-dropdown/index.jsx
87,113c87,107
<     const dropdownTrigger = ({
<       triggerRef,
<       ariaLabel,
<       isOpen,
<       testUtilsClass,
<       disabled,
<       onClick
<     }) => {
<       return (
<         <ButtonTrigger
<           testUtilsClass={testUtilsClass}
<           ref={triggerRef}
<           disabled={disabled}
<           expanded={isOpen}
<           iconName={iconName}
<           iconUrl={iconUrl}
<           iconAlt={iconAlt}
<           iconSvg={iconSvg}
<           badge={badge}
<           ariaLabel={ariaLabel}
<           offsetRight={offsetRight}
<           onClick={onClick}>
<           {children}
<         </ButtonTrigger>
<       )
<     }
< 
---
>     const dropdownTrigger = memo(
>       ({triggerRef, ariaLabel, isOpen, testUtilsClass, disabled, onClick}) => {
>         return (
>           <ButtonTrigger
>             testUtilsClass={testUtilsClass}
>             ref={triggerRef}
>             disabled={disabled}
>             expanded={isOpen}
>             iconName={iconName}
>             iconUrl={iconUrl}
>             iconAlt={iconAlt}
>             iconSvg={iconSvg}
>             badge={badge}
>             ariaLabel={ariaLabel}
>             offsetRight={offsetRight}
>             onClick={onClick}>
>             {children}
>           </ButtonTrigger>
>         )
>       }
>     )
diff -r src/components/internal/components/option/highlight-match.jsx ../cloudcomp/lib/components/internal/components/option/highlight-match.jsx
32,37c32,39
<   noMatches.forEach((noMatch, idx) => {
<     highlighted.push(<span key={`noMatch-${idx}`}>{noMatch}</span>)
<     if (matches && idx < matches.length) {
<       highlighted.push(<Highlight key={`match-${idx}`} str={matches[idx]} />)
<     }
<   })
---
>   noMatches.forEach(
>     memo((noMatch, idx) => {
>       highlighted.push(<span key={`noMatch-${idx}`}>{noMatch}</span>)
>       if (matches && idx < matches.length) {
>         highlighted.push(<Highlight key={`match-${idx}`} str={matches[idx]} />)
>       }
>     })
>   )
diff -r src/components/internal/components/option/option-parts.jsx ../cloudcomp/lib/components/internal/components/option/option-parts.jsx
69,78c69,80
<         {tags.map((tag, idx) => (
<           <span
<             key={idx}
<             className={clsx(
<               styles.tag,
<               triggerVariant && styles['trigger-variant']
<             )}>
<             <HighlightMatch str={tag} highlightText={highlightText} />
<           </span>
<         ))}
---
>         {tags.map(
>           memo((tag, idx) => (
>             <span
>               key={idx}
>               className={clsx(
>                 styles.tag,
>                 triggerVariant && styles['trigger-variant']
>               )}>
>               <HighlightMatch str={tag} highlightText={highlightText} />
>             </span>
>           ))
>         )}
100,120c102,124
<         {filteringTags.map((filteringTag, key) => {
<           const match =
<             filteringTag.toLowerCase().indexOf(searchElement) !== -1
<           if (match) {
<             return (
<               <span
<                 className={clsx(
<                   styles.tag,
<                   triggerVariant && styles['trigger-variant']
<                 )}
<                 key={key}
<                 aria-disabled={true}>
<                 <HighlightMatch
<                   str={filteringTag}
<                   highlightText={highlightText}
<                 />
<               </span>
<             )
<           }
<           return null
<         })}
---
>         {filteringTags.map(
>           memo((filteringTag, key) => {
>             const match =
>               filteringTag.toLowerCase().indexOf(searchElement) !== -1
>             if (match) {
>               return (
>                 <span
>                   className={clsx(
>                     styles.tag,
>                     triggerVariant && styles['trigger-variant']
>                   )}
>                   key={key}
>                   aria-disabled={true}>
>                   <HighlightMatch
>                     str={filteringTag}
>                     highlightText={highlightText}
>                   />
>                 </span>
>               )
>             }
>             return null
>           })
>         )}
diff -r src/components/internal/components/token-list/index.jsx ../cloudcomp/lib/components/internal/components/token-list/index.jsx
54,62c54,64
<               {visibleItems.map((item, itemIndex) => (
<                 <li
<                   key={itemIndex}
<                   className={styles['list-item']}
<                   aria-setsize={items.length}
<                   aria-posinset={itemIndex + 1}>
<                   {renderItem(item, itemIndex)}
<                 </li>
<               ))}
---
>               {visibleItems.map(
>                 memo((item, itemIndex) => (
>                   <li
>                     key={itemIndex}
>                     className={styles['list-item']}
>                     aria-setsize={items.length}
>                     aria-posinset={itemIndex + 1}>
>                     {renderItem(item, itemIndex)}
>                   </li>
>                 ))
>               )}
75,83c77,87
<             {visibleItems.map((item, itemIndex) => (
<               <li
<                 key={itemIndex}
<                 className={styles['list-item']}
<                 aria-setsize={items.length}
<                 aria-posinset={itemIndex + 1}>
<                 {renderItem(item, itemIndex)}
<               </li>
<             ))}
---
>             {visibleItems.map(
>               memo((item, itemIndex) => (
>                 <li
>                   key={itemIndex}
>                   className={styles['list-item']}
>                   aria-setsize={items.length}
>                   aria-posinset={itemIndex + 1}>
>                   {renderItem(item, itemIndex)}
>                 </li>
>               ))
>             )}
diff -r src/components/internal/components/tooltip/index.jsx ../cloudcomp/lib/components/internal/components/tooltip/index.jsx
15c15
<           {() => (
---
>           {memo(() => (
22c22
<               arrow={position => (
---
>               arrow={memo(position => (
31c31
<               )}>
---
>               ))}>
40c40
<           )}
---
>           ))}
diff -r src/components/internal/environment.js ../cloudcomp/lib/components/internal/environment.js
2c2
< const PACKAGE_VERSION = '3.0.0 (1ec19bb1)'
---
> const PACKAGE_VERSION = '3.0.0 (c7716c2e)'
diff -r src/components/internal/hooks/use-dynamic-overlap/index.js ../cloudcomp/lib/components/internal/hooks/use-dynamic-overlap/index.js
23c23
<     () => {
---
>     function handleDynamicOverlapHeight() {
diff -r src/components/internal/plugins/api.js ../cloudcomp/lib/components/internal/plugins/api.js
18c18,27
< 
---
> const loadApi = () => {
>   if (typeof window === 'undefined') {
>     return installApi({})
>   }
>   const win = window
>   const existingApi = findUpApi(win)
>   win[storageKey] = installApi(existingApi ?? {})
>   return win[storageKey]
> }
> const {awsuiPlugins, awsuiPluginsInternal} = loadApi()
43,54d51
< 
< const loadApi = () => {
<   if (typeof window === 'undefined') {
<     return installApi({})
<   }
<   const win = window
<   const existingApi = findUpApi(win)
<   win[storageKey] = installApi(existingApi ?? {})
<   return win[storageKey]
< }
< 
< const {awsuiPlugins, awsuiPluginsInternal} = loadApi()
diff -r src/components/internal/plugins/helpers/use-discovered-action.jsx ../cloudcomp/lib/components/internal/plugins/helpers/use-discovered-action.jsx
1c1
< import {useEffect, useRef, useState} from 'react'
---
> import {useEffect, useRef, useState, memo} from 'react'
4c4
< const convertRuntimeAction = (action, context) => {
---
> const convertRuntimeAction = memo((action, context) => {
15c15
< }
---
> })
18c18
<   return type => {
---
>   return function useDiscoveredAction(type) {
diff -r src/components/popover/internal.jsx ../cloudcomp/lib/components/popover/internal.jsx
29,78c29,64
<   forwardRef(
<     (
<       {
<         position = 'right',
<         size = 'medium',
<         fixedWidth = false,
<         triggerType = 'text',
<         dismissButton = true,
<         children,
<         header,
<         content,
<         triggerAriaLabel,
<         renderWithPortal = false,
<         __onOpen,
<         __internalRootRef = null,
<         ...restProps
<       },
<       ref
<     ) => {
<       const baseProps = getBaseProps(restProps)
<       const triggerRef = useRef(null)
<       const popoverRef = useRef(null)
<       const clickFrameId = useRef(null)
<       const i18n = useInternalI18n('popover')
<       const dismissAriaLabel = i18n(
<         'dismissAriaLabel',
<         restProps.dismissAriaLabel
<       )
<       const [visible, setVisible] = useState(false)
<       const focusTrigger = useCallback(() => {
<         if (triggerType === 'text') {
<           triggerRef.current?.focus()
<         } else {
<           triggerRef.current && getFirstFocusable(triggerRef.current)?.focus()
<         }
<       }, [triggerType])
<       const onTriggerClick = useCallback(() => {
<         fireNonCancelableEvent(__onOpen)
<         setVisible(true)
<       }, [__onOpen])
<       const onDismiss = useCallback(() => {
<         setVisible(false)
<         focusTrigger()
<       }, [focusTrigger])
<       const onTriggerKeyDown = useCallback(
<         event => {
<           const isEscapeKey = event.keyCode === KeyCode.escape
<           const isTabKey = event.keyCode === KeyCode.tab
<           if (isEscapeKey && visible) {
<             event.stopPropagation()
---
>   memo(
>     forwardRef(
>       (
>         {
>           position = 'right',
>           size = 'medium',
>           fixedWidth = false,
>           triggerType = 'text',
>           dismissButton = true,
>           children,
>           header,
>           content,
>           triggerAriaLabel,
>           renderWithPortal = false,
>           __onOpen,
>           __internalRootRef = null,
>           ...restProps
>         },
>         ref
>       ) => {
>         const baseProps = getBaseProps(restProps)
>         const triggerRef = useRef(null)
>         const popoverRef = useRef(null)
>         const clickFrameId = useRef(null)
>         const i18n = useInternalI18n('popover')
>         const dismissAriaLabel = i18n(
>           'dismissAriaLabel',
>           restProps.dismissAriaLabel
>         )
>         const [visible, setVisible] = useState(false)
>         const focusTrigger = useCallback(() => {
>           if (triggerType === 'text') {
>             triggerRef.current?.focus()
>           } else {
>             triggerRef.current &&
>               getFirstFocusable(triggerRef.current)?.focus()
80,81c66,93
<           if (isTabKey || isEscapeKey) {
<             setVisible(false)
---
>         }, [triggerType])
>         const onTriggerClick = useCallback(() => {
>           fireNonCancelableEvent(__onOpen)
>           setVisible(true)
>         }, [__onOpen])
>         const onDismiss = useCallback(() => {
>           setVisible(false)
>           focusTrigger()
>         }, [focusTrigger])
>         const onTriggerKeyDown = useCallback(
>           event => {
>             const isEscapeKey = event.keyCode === KeyCode.escape
>             const isTabKey = event.keyCode === KeyCode.tab
>             if (isEscapeKey && visible) {
>               event.stopPropagation()
>             }
>             if (isTabKey || isEscapeKey) {
>               setVisible(false)
>             }
>           },
>           [visible]
>         )
>         useImperativeHandle(ref, () => ({
>           dismissPopover: onDismiss
>         }))
>         useEffect(() => {
>           if (!triggerRef.current) {
>             return
83,96c95,99
<         },
<         [visible]
<       )
<       useImperativeHandle(ref, () => ({
<         dismissPopover: onDismiss
<       }))
<       useEffect(() => {
<         if (!triggerRef.current) {
<           return
<         }
<         const document = triggerRef.current.ownerDocument
<         const onDocumentClick = () => {
<           if (clickFrameId.current === null) {
<             setVisible(false)
---
>           const document = triggerRef.current.ownerDocument
>           const onDocumentClick = () => {
>             if (clickFrameId.current === null) {
>               setVisible(false)
>             }
97a101,114
>           document.addEventListener('mousedown', onDocumentClick, false)
>           return () => {
>             document.removeEventListener('mousedown', onDocumentClick, false)
>           }
>         }, [])
>         const popoverClasses = usePortalModeClasses(triggerRef)
>         const triggerProps = {
>           ref: triggerRef,
>           onClick: onTriggerClick,
>           onKeyDown: onTriggerKeyDown,
>           className: clsx(
>             styles.trigger,
>             styles[`trigger-type-${triggerType}`]
>           )
99,174c116,173
<         document.addEventListener('mousedown', onDocumentClick, false)
<         return () => {
<           document.removeEventListener('mousedown', onDocumentClick, false)
<         }
<       }, [])
<       const popoverClasses = usePortalModeClasses(triggerRef)
<       const triggerProps = {
<         ref: triggerRef,
<         onClick: onTriggerClick,
<         onKeyDown: onTriggerKeyDown,
<         className: clsx(styles.trigger, styles[`trigger-type-${triggerType}`])
<       }
<       const {tabIndex: triggerTabIndex} =
<         useSingleTabStopNavigation(triggerRef)
<       const referrerId = useUniqueId()
<       const popoverContent = (
<         <div
<           aria-live={dismissButton ? void 0 : 'polite'}
<           aria-atomic={dismissButton ? void 0 : true}
<           className={clsx(
<             popoverClasses,
<             visible && styles['popover-content']
<           )}>
<           {visible && (
<             <PopoverContainer
<               size={size}
<               fixedWidth={fixedWidth}
<               position={position}
<               trackRef={triggerRef}
<               arrow={position2 => <Arrow position={position2} />}
<               renderWithPortal={renderWithPortal}
<               zIndex={renderWithPortal ? 7e3 : void 0}>
<               <LinkDefaultVariantContext.Provider
<                 value={{defaultVariant: 'primary'}}>
<                 <PopoverBody
<                   dismissButton={dismissButton}
<                   dismissAriaLabel={dismissAriaLabel}
<                   header={header}
<                   onDismiss={onDismiss}
<                   overflowVisible='both'>
<                   {content}
<                 </PopoverBody>
<               </LinkDefaultVariantContext.Provider>
<             </PopoverContainer>
<           )}
<         </div>
<       )
<       const mergedRef = useMergeRefs(popoverRef, __internalRootRef)
<       return (
<         <span
<           {...baseProps}
<           className={clsx(styles.root, baseProps.className)}
<           ref={mergedRef}
<           onMouseDown={() => {
<             clickFrameId.current = requestAnimationFrame(() => {
<               clickFrameId.current = null
<             })
<           }}>
<           {triggerType === 'text' ? (
<             <button
<               {...triggerProps}
<               tabIndex={triggerTabIndex}
<               type='button'
<               aria-haspopup='dialog'
<               id={referrerId}
<               aria-label={triggerAriaLabel}>
<               <span className={styles['trigger-inner-text']}>{children}</span>
<             </button>
<           ) : (
<             <span {...triggerProps} id={referrerId}>
<               {children}
<             </span>
<           )}
<           <ResetContextsForModal>
<             {renderWithPortal ? (
<               <Portal>{popoverContent}</Portal>
---
>         const {tabIndex: triggerTabIndex} =
>           useSingleTabStopNavigation(triggerRef)
>         const referrerId = useUniqueId()
>         const popoverContent = (
>           <div
>             aria-live={dismissButton ? void 0 : 'polite'}
>             aria-atomic={dismissButton ? void 0 : true}
>             className={clsx(
>               popoverClasses,
>               visible && styles['popover-content']
>             )}>
>             {visible && (
>               <PopoverContainer
>                 size={size}
>                 fixedWidth={fixedWidth}
>                 position={position}
>                 trackRef={triggerRef}
>                 arrow={position2 => <Arrow position={position2} />}
>                 renderWithPortal={renderWithPortal}
>                 zIndex={renderWithPortal ? 7e3 : void 0}>
>                 <LinkDefaultVariantContext.Provider
>                   value={{defaultVariant: 'primary'}}>
>                   <PopoverBody
>                     dismissButton={dismissButton}
>                     dismissAriaLabel={dismissAriaLabel}
>                     header={header}
>                     onDismiss={onDismiss}
>                     overflowVisible='both'>
>                     {content}
>                   </PopoverBody>
>                 </LinkDefaultVariantContext.Provider>
>               </PopoverContainer>
>             )}
>           </div>
>         )
>         const mergedRef = useMergeRefs(popoverRef, __internalRootRef)
>         return (
>           <span
>             {...baseProps}
>             className={clsx(styles.root, baseProps.className)}
>             ref={mergedRef}
>             onMouseDown={() => {
>               clickFrameId.current = requestAnimationFrame(() => {
>                 clickFrameId.current = null
>               })
>             }}>
>             {triggerType === 'text' ? (
>               <button
>                 {...triggerProps}
>                 tabIndex={triggerTabIndex}
>                 type='button'
>                 aria-haspopup='dialog'
>                 id={referrerId}
>                 aria-label={triggerAriaLabel}>
>                 <span className={styles['trigger-inner-text']}>
>                   {children}
>                 </span>
>               </button>
176c175,177
<               popoverContent
---
>               <span {...triggerProps} id={referrerId}>
>                 {children}
>               </span>
178,181c179,189
<           </ResetContextsForModal>
<         </span>
<       )
<     }
---
>             <ResetContextsForModal>
>               {renderWithPortal ? (
>                 <Portal>{popoverContent}</Portal>
>               ) : (
>                 popoverContent
>               )}
>             </ResetContextsForModal>
>           </span>
>         )
>       }
>     )
diff -r src/components/property-filter/index.jsx ../cloudcomp/lib/components/property-filter/index.jsx
53,91c53,59
<   forwardRef(
<     (
<       {
<         disabled,
<         countText,
<         query,
<         hideOperations,
<         onChange,
<         filteringProperties,
<         filteringOptions = [],
<         customGroupsText = [],
<         disableFreeTextFiltering = false,
<         freeTextFiltering,
<         onLoadItems,
<         virtualScroll,
<         customControl,
<         customFilterActions,
<         filteringPlaceholder,
<         filteringAriaLabel,
<         filteringEmpty,
<         filteringLoadingText,
<         filteringFinishedText,
<         filteringErrorText,
<         filteringRecoveryText,
<         filteringStatusType,
<         asyncProperties,
<         tokenLimit,
<         expandToViewport,
<         tokenLimitShowFewerAriaLabel,
<         tokenLimitShowMoreAriaLabel,
<         ...rest
<       },
<       ref
<     ) => {
<       const {__internalRootRef} = useBaseComponent('PropertyFilter', {
<         props: {
<           asyncProperties,
<           disableFreeTextFiltering,
<           expandToViewport,
---
>   memo(
>     forwardRef(
>       (
>         {
>           disabled,
>           countText,
>           query,
92a61,79
>           onChange,
>           filteringProperties,
>           filteringOptions = [],
>           customGroupsText = [],
>           disableFreeTextFiltering = false,
>           freeTextFiltering,
>           onLoadItems,
>           virtualScroll,
>           customControl,
>           customFilterActions,
>           filteringPlaceholder,
>           filteringAriaLabel,
>           filteringEmpty,
>           filteringLoadingText,
>           filteringFinishedText,
>           filteringErrorText,
>           filteringRecoveryText,
>           filteringStatusType,
>           asyncProperties,
94,232c81,212
<           virtualScroll
<         }
<       })
<       const [removedTokenIndex, setRemovedTokenIndex] = useState(null)
<       const inputRef = useRef(null)
<       const baseProps = getBaseProps(rest)
<       const i18n = useInternalI18n('property-filter')
<       const i18nStrings = {
<         ...rest.i18nStrings,
<         allPropertiesLabel: i18n(
<           'i18nStrings.allPropertiesLabel',
<           rest.i18nStrings?.allPropertiesLabel
<         ),
<         applyActionText: i18n(
<           'i18nStrings.applyActionText',
<           rest.i18nStrings?.applyActionText
<         ),
<         cancelActionText: i18n(
<           'i18nStrings.cancelActionText',
<           rest.i18nStrings?.cancelActionText
<         ),
<         clearFiltersText: i18n(
<           'i18nStrings.clearFiltersText',
<           rest.i18nStrings?.clearFiltersText
<         ),
<         editTokenHeader: i18n(
<           'i18nStrings.editTokenHeader',
<           rest.i18nStrings?.editTokenHeader
<         ),
<         groupPropertiesText: i18n(
<           'i18nStrings.groupPropertiesText',
<           rest.i18nStrings?.groupPropertiesText
<         ),
<         groupValuesText: i18n(
<           'i18nStrings.groupValuesText',
<           rest.i18nStrings?.groupValuesText
<         ),
<         operationAndText: i18n(
<           'i18nStrings.operationAndText',
<           rest.i18nStrings?.operationAndText
<         ),
<         operationOrText: i18n(
<           'i18nStrings.operationOrText',
<           rest.i18nStrings?.operationOrText
<         ),
<         operatorContainsText: i18n(
<           'i18nStrings.operatorContainsText',
<           rest.i18nStrings?.operatorContainsText
<         ),
<         operatorDoesNotContainText: i18n(
<           'i18nStrings.operatorDoesNotContainText',
<           rest.i18nStrings?.operatorDoesNotContainText
<         ),
<         operatorDoesNotEqualText: i18n(
<           'i18nStrings.operatorDoesNotEqualText',
<           rest.i18nStrings?.operatorDoesNotEqualText
<         ),
<         operatorEqualsText: i18n(
<           'i18nStrings.operatorEqualsText',
<           rest.i18nStrings?.operatorEqualsText
<         ),
<         operatorGreaterOrEqualText: i18n(
<           'i18nStrings.operatorGreaterOrEqualText',
<           rest.i18nStrings?.operatorGreaterOrEqualText
<         ),
<         operatorGreaterText: i18n(
<           'i18nStrings.operatorGreaterText',
<           rest.i18nStrings?.operatorGreaterText
<         ),
<         operatorLessOrEqualText: i18n(
<           'i18nStrings.operatorLessOrEqualText',
<           rest.i18nStrings?.operatorLessOrEqualText
<         ),
<         operatorLessText: i18n(
<           'i18nStrings.operatorLessText',
<           rest.i18nStrings?.operatorLessText
<         ),
<         operatorStartsWithText: i18n(
<           'i18nStrings.operatorStartsWithText',
<           rest.i18nStrings?.operatorStartsWithText
<         ),
<         operatorDoesNotStartWithText: i18n(
<           'i18nStrings.operatorDoesNotStartWithText',
<           rest.i18nStrings?.operatorDoesNotStartWithText
<         ),
<         operatorText: i18n(
<           'i18nStrings.operatorText',
<           rest.i18nStrings?.operatorText
<         ),
<         operatorsText: i18n(
<           'i18nStrings.operatorsText',
<           rest.i18nStrings?.operatorsText
<         ),
<         propertyText: i18n(
<           'i18nStrings.propertyText',
<           rest.i18nStrings?.propertyText
<         ),
<         tokenLimitShowFewer: i18n(
<           'i18nStrings.tokenLimitShowFewer',
<           rest.i18nStrings?.tokenLimitShowFewer
<         ),
<         tokenLimitShowMore: i18n(
<           'i18nStrings.tokenLimitShowMore',
<           rest.i18nStrings?.tokenLimitShowMore
<         ),
<         valueText: i18n('i18nStrings.valueText', rest.i18nStrings?.valueText),
<         removeTokenButtonAriaLabel: i18n(
<           'i18nStrings.removeTokenButtonAriaLabel',
<           rest.i18nStrings?.removeTokenButtonAriaLabel,
<           format => token =>
<             format({
<               token__operator: getOperatorI18nString(token.operator),
<               token__propertyKey: token.propertyKey ?? '',
<               token__value: token.value
<             })
<         )
<       }
<       useImperativeHandle(
<         ref,
<         () => ({focus: () => inputRef.current?.focus()}),
<         []
<       )
<       const showResults = !!query.tokens?.length && !disabled && !!countText
<       const {addToken, removeToken, setToken, setOperation, removeAllTokens} =
<         getQueryActions(query, onChange, inputRef)
<       const [filteringText, setFilteringText] = useState('')
<       const {
<         internalProperties,
<         internalOptions,
<         internalQuery,
<         internalFreeText
<       } = (() => {
<         const propertyByKey = filteringProperties.reduce((acc, property) => {
<           const extendedOperators = (property?.operators ?? []).reduce(
<             (acc2, operator) =>
<               typeof operator === 'object'
<                 ? acc2.set(operator.operator, operator)
<                 : acc2,
<             new Map()
---
>           expandToViewport,
>           tokenLimitShowFewerAriaLabel,
>           tokenLimitShowMoreAriaLabel,
>           ...rest
>         },
>         ref
>       ) => {
>         const {__internalRootRef} = useBaseComponent('PropertyFilter', {
>           props: {
>             asyncProperties,
>             disableFreeTextFiltering,
>             expandToViewport,
>             hideOperations,
>             tokenLimit,
>             virtualScroll
>           }
>         })
>         const [removedTokenIndex, setRemovedTokenIndex] = useState(null)
>         const inputRef = useRef(null)
>         const baseProps = getBaseProps(rest)
>         const i18n = useInternalI18n('property-filter')
>         const i18nStrings = {
>           ...rest.i18nStrings,
>           allPropertiesLabel: i18n(
>             'i18nStrings.allPropertiesLabel',
>             rest.i18nStrings?.allPropertiesLabel
>           ),
>           applyActionText: i18n(
>             'i18nStrings.applyActionText',
>             rest.i18nStrings?.applyActionText
>           ),
>           cancelActionText: i18n(
>             'i18nStrings.cancelActionText',
>             rest.i18nStrings?.cancelActionText
>           ),
>           clearFiltersText: i18n(
>             'i18nStrings.clearFiltersText',
>             rest.i18nStrings?.clearFiltersText
>           ),
>           editTokenHeader: i18n(
>             'i18nStrings.editTokenHeader',
>             rest.i18nStrings?.editTokenHeader
>           ),
>           groupPropertiesText: i18n(
>             'i18nStrings.groupPropertiesText',
>             rest.i18nStrings?.groupPropertiesText
>           ),
>           groupValuesText: i18n(
>             'i18nStrings.groupValuesText',
>             rest.i18nStrings?.groupValuesText
>           ),
>           operationAndText: i18n(
>             'i18nStrings.operationAndText',
>             rest.i18nStrings?.operationAndText
>           ),
>           operationOrText: i18n(
>             'i18nStrings.operationOrText',
>             rest.i18nStrings?.operationOrText
>           ),
>           operatorContainsText: i18n(
>             'i18nStrings.operatorContainsText',
>             rest.i18nStrings?.operatorContainsText
>           ),
>           operatorDoesNotContainText: i18n(
>             'i18nStrings.operatorDoesNotContainText',
>             rest.i18nStrings?.operatorDoesNotContainText
>           ),
>           operatorDoesNotEqualText: i18n(
>             'i18nStrings.operatorDoesNotEqualText',
>             rest.i18nStrings?.operatorDoesNotEqualText
>           ),
>           operatorEqualsText: i18n(
>             'i18nStrings.operatorEqualsText',
>             rest.i18nStrings?.operatorEqualsText
>           ),
>           operatorGreaterOrEqualText: i18n(
>             'i18nStrings.operatorGreaterOrEqualText',
>             rest.i18nStrings?.operatorGreaterOrEqualText
>           ),
>           operatorGreaterText: i18n(
>             'i18nStrings.operatorGreaterText',
>             rest.i18nStrings?.operatorGreaterText
>           ),
>           operatorLessOrEqualText: i18n(
>             'i18nStrings.operatorLessOrEqualText',
>             rest.i18nStrings?.operatorLessOrEqualText
>           ),
>           operatorLessText: i18n(
>             'i18nStrings.operatorLessText',
>             rest.i18nStrings?.operatorLessText
>           ),
>           operatorStartsWithText: i18n(
>             'i18nStrings.operatorStartsWithText',
>             rest.i18nStrings?.operatorStartsWithText
>           ),
>           operatorDoesNotStartWithText: i18n(
>             'i18nStrings.operatorDoesNotStartWithText',
>             rest.i18nStrings?.operatorDoesNotStartWithText
>           ),
>           operatorText: i18n(
>             'i18nStrings.operatorText',
>             rest.i18nStrings?.operatorText
>           ),
>           operatorsText: i18n(
>             'i18nStrings.operatorsText',
>             rest.i18nStrings?.operatorsText
>           ),
>           propertyText: i18n(
>             'i18nStrings.propertyText',
>             rest.i18nStrings?.propertyText
>           ),
>           tokenLimitShowFewer: i18n(
>             'i18nStrings.tokenLimitShowFewer',
>             rest.i18nStrings?.tokenLimitShowFewer
>           ),
>           tokenLimitShowMore: i18n(
>             'i18nStrings.tokenLimitShowMore',
>             rest.i18nStrings?.tokenLimitShowMore
>           ),
>           valueText: i18n(
>             'i18nStrings.valueText',
>             rest.i18nStrings?.valueText
>           ),
>           removeTokenButtonAriaLabel: i18n(
>             'i18nStrings.removeTokenButtonAriaLabel',
>             rest.i18nStrings?.removeTokenButtonAriaLabel,
>             format => token =>
>               format({
>                 token__operator: getOperatorI18nString(token.operator),
>                 token__propertyKey: token.propertyKey ?? '',
>                 token__value: token.value
>               })
234,279d213
<           acc.set(property.key, {
<             propertyKey: property.key,
<             propertyLabel: property?.propertyLabel ?? '',
<             groupValuesLabel: property?.groupValuesLabel ?? '',
<             propertyGroup: property?.group,
<             operators: (property?.operators ?? []).map(op =>
<               typeof op === 'string' ? op : op.operator
<             ),
<             defaultOperator: property?.defaultOperator ?? '=',
<             getValueFormatter: operator =>
<               operator
<                 ? extendedOperators.get(operator)?.format ?? null
<                 : null,
<             getValueFormRenderer: operator =>
<               operator ? extendedOperators.get(operator)?.form ?? null : null,
<             externalProperty: property
<           })
<           return acc
<         }, new Map())
<         const getProperty = propertyKey =>
<           propertyByKey.get(propertyKey) ?? null
<         const internalOptions2 = filteringOptions.map(option => ({
<           property: getProperty(option.propertyKey),
<           value: option.value,
<           label: option.label ?? option.value ?? ''
<         }))
<         const internalQuery2 = {
<           operation: query.operation,
<           tokens: query.tokens.map(token => ({
<             property: token.propertyKey
<               ? getProperty(token.propertyKey)
<               : null,
<             operator: token.operator,
<             value: token.value
<           }))
<         }
<         const internalFreeText2 = {
<           disabled: disableFreeTextFiltering,
<           operators: freeTextFiltering?.operators ?? [':', '!:'],
<           defaultOperator: freeTextFiltering?.defaultOperator ?? ':'
<         }
<         return {
<           internalProperties: [...propertyByKey.values()],
<           internalOptions: internalOptions2,
<           internalQuery: internalQuery2,
<           internalFreeText: internalFreeText2
281,296c215,229
<       })()
<       const parsedText = parseText(
<         filteringText,
<         internalProperties,
<         internalFreeText
<       )
<       const autosuggestOptions = getAutosuggestOptions(
<         parsedText,
<         internalProperties,
<         internalOptions,
<         customGroupsText,
<         i18nStrings
<       )
<       const createToken = currentText => {
<         const parsedText2 = parseText(
<           currentText,
---
>         useImperativeHandle(
>           ref,
>           () => ({focus: () => inputRef.current?.focus()}),
>           []
>         )
>         const showResults = !!query.tokens?.length && !disabled && !!countText
>         const {
>           addToken,
>           removeToken,
>           setToken,
>           setOperation,
>           removeAllTokens
>         } = getQueryActions(query, onChange, inputRef)
>         const [filteringText, setFilteringText] = useState('')
>         const {
297a231,232
>           internalOptions,
>           internalQuery,
299,309c234,241
<         )
<         let newToken
<         switch (parsedText2.step) {
<           case 'property': {
<             newToken = matchTokenValue(
<               {
<                 property: parsedText2.property,
<                 operator: parsedText2.operator,
<                 value: parsedText2.value
<               },
<               internalOptions
---
>         } = (() => {
>           const propertyByKey = filteringProperties.reduce((acc, property) => {
>             const extendedOperators = (property?.operators ?? []).reduce(
>               (acc2, operator) =>
>                 typeof operator === 'object'
>                   ? acc2.set(operator.operator, operator)
>                   : acc2,
>               new Map()
311c243,279
<             break
---
>             acc.set(property.key, {
>               propertyKey: property.key,
>               propertyLabel: property?.propertyLabel ?? '',
>               groupValuesLabel: property?.groupValuesLabel ?? '',
>               propertyGroup: property?.group,
>               operators: (property?.operators ?? []).map(op =>
>                 typeof op === 'string' ? op : op.operator
>               ),
>               defaultOperator: property?.defaultOperator ?? '=',
>               getValueFormatter: operator =>
>                 operator
>                   ? extendedOperators.get(operator)?.format ?? null
>                   : null,
>               getValueFormRenderer: operator =>
>                 operator
>                   ? extendedOperators.get(operator)?.form ?? null
>                   : null,
>               externalProperty: property
>             })
>             return acc
>           }, new Map())
>           const getProperty = propertyKey =>
>             propertyByKey.get(propertyKey) ?? null
>           const internalOptions2 = filteringOptions.map(option => ({
>             property: getProperty(option.propertyKey),
>             value: option.value,
>             label: option.label ?? option.value ?? ''
>           }))
>           const internalQuery2 = {
>             operation: query.operation,
>             tokens: query.tokens.map(token => ({
>               property: token.propertyKey
>                 ? getProperty(token.propertyKey)
>                 : null,
>               operator: token.operator,
>               value: token.value
>             }))
313,319c281,284
<           case 'free-text': {
<             newToken = {
<               operator:
<                 parsedText2.operator || internalFreeText.defaultOperator,
<               value: parsedText2.value
<             }
<             break
---
>           const internalFreeText2 = {
>             disabled: disableFreeTextFiltering,
>             operators: freeTextFiltering?.operators ?? [':', '!:'],
>             defaultOperator: freeTextFiltering?.defaultOperator ?? ':'
321,326c286,290
<           case 'operator': {
<             newToken = {
<               operator: internalFreeText.defaultOperator,
<               value: currentText
<             }
<             break
---
>           return {
>             internalProperties: [...propertyByKey.values()],
>             internalOptions: internalOptions2,
>             internalQuery: internalQuery2,
>             internalFreeText: internalFreeText2
328,395c292,294
<         }
<         if (internalFreeText.disabled && !('propertyKey' in newToken)) {
<           return
<         }
<         addToken(newToken)
<         setFilteringText('')
<       }
<       const ignoreKeyDown = useRef(false)
<       const handleKeyDown = event => {
<         if (
<           filteringText &&
<           !ignoreKeyDown.current &&
<           event.detail.keyCode === KeyCode.enter
<         ) {
<           createToken(filteringText)
<         }
<       }
<       const getLoadMoreDetail = (parsedText2, filteringText2) => {
<         const loadMoreDetail2 = {
<           filteringProperty: void 0,
<           filteringText: filteringText2,
<           filteringOperator: void 0
<         }
<         if (parsedText2.step === 'property') {
<           loadMoreDetail2.filteringProperty =
<             parsedText2.property.externalProperty
<           loadMoreDetail2.filteringText = parsedText2.value
<           loadMoreDetail2.filteringOperator = parsedText2.operator
<         }
<         return loadMoreDetail2
<       }
<       const loadMoreDetail = getLoadMoreDetail(parsedText, filteringText)
<       const inputLoadItemsHandlers = useLoadItems(
<         onLoadItems,
<         loadMoreDetail.filteringText,
<         loadMoreDetail.filteringProperty,
<         loadMoreDetail.filteringText,
<         loadMoreDetail.filteringOperator
<       )
<       const asyncProps = {
<         empty: filteringEmpty,
<         loadingText: filteringLoadingText,
<         finishedText: filteringFinishedText,
<         errorText: filteringErrorText,
<         recoveryText: filteringRecoveryText,
<         statusType: filteringStatusType
<       }
<       const asyncAutosuggestProps =
<         !!filteringText.length || asyncProperties
<           ? {
<               ...inputLoadItemsHandlers,
<               ...asyncProps
<             }
<           : {}
<       const handleSelected = event => {
<         ignoreKeyDown.current = true
<         setTimeout(() => {
<           ignoreKeyDown.current = false
<         }, 0)
<         const {detail: option} = event
<         const value = option.value || ''
<         if (!('keepOpenOnSelect' in option)) {
<           createToken(value)
<           return
<         }
<         event.preventDefault()
<         const parsedText2 = parseText(
<           value,
---
>         })()
>         const parsedText = parseText(
>           filteringText,
399,401c298,347
<         const loadMoreDetail2 = getLoadMoreDetail(parsedText2, value)
<         if (parsedText2.step === 'operator') {
<           const operators = getAllowedOperators(parsedText2.property)
---
>         const autosuggestOptions = getAutosuggestOptions(
>           parsedText,
>           internalProperties,
>           internalOptions,
>           customGroupsText,
>           i18nStrings
>         )
>         const createToken = currentText => {
>           const parsedText2 = parseText(
>             currentText,
>             internalProperties,
>             internalFreeText
>           )
>           let newToken
>           switch (parsedText2.step) {
>             case 'property': {
>               newToken = matchTokenValue(
>                 {
>                   property: parsedText2.property,
>                   operator: parsedText2.operator,
>                   value: parsedText2.value
>                 },
>                 internalOptions
>               )
>               break
>             }
>             case 'free-text': {
>               newToken = {
>                 operator:
>                   parsedText2.operator || internalFreeText.defaultOperator,
>                 value: parsedText2.value
>               }
>               break
>             }
>             case 'operator': {
>               newToken = {
>                 operator: internalFreeText.defaultOperator,
>                 value: currentText
>               }
>               break
>             }
>           }
>           if (internalFreeText.disabled && !('propertyKey' in newToken)) {
>             return
>           }
>           addToken(newToken)
>           setFilteringText('')
>         }
>         const ignoreKeyDown = useRef(false)
>         const handleKeyDown = event => {
403,404c349,351
<             value.trim() === parsedText2.property.propertyLabel &&
<             operators.length === 1
---
>             filteringText &&
>             !ignoreKeyDown.current &&
>             event.detail.keyCode === KeyCode.enter
405a353,362
>             createToken(filteringText)
>           }
>         }
>         const getLoadMoreDetail = (parsedText2, filteringText2) => {
>           const loadMoreDetail2 = {
>             filteringProperty: void 0,
>             filteringText: filteringText2,
>             filteringOperator: void 0
>           }
>           if (parsedText2.step === 'property') {
407,412c364,366
<               parsedText2.property.externalProperty ?? void 0
<             loadMoreDetail2.filteringOperator = operators[0]
<             loadMoreDetail2.filteringText = ''
<             setFilteringText(
<               parsedText2.property.propertyLabel + ' ' + operators[0] + ' '
<             )
---
>               parsedText2.property.externalProperty
>             loadMoreDetail2.filteringText = parsedText2.value
>             loadMoreDetail2.filteringOperator = parsedText2.operator
413a368
>           return loadMoreDetail2
415,440c370,390
<         fireNonCancelableEvent(onLoadItems, {
<           ...loadMoreDetail2,
<           firstPage: true,
<           samePage: false
<         })
<       }
<       const operatorForm =
<         parsedText.step === 'property' &&
<         parsedText.property.getValueFormRenderer(parsedText.operator)
<       const searchResultsId = useUniqueId('property-filter-search-results')
<       return (
<         <div
<           {...baseProps}
<           className={clsx(baseProps.className, styles.root)}
<           ref={__internalRootRef}>
<           <div className={styles['search-field']}>
<             {customControl && (
<               <div className={styles['custom-control']}>{customControl}</div>
<             )}
<             <PropertyFilterAutosuggest
<               ref={inputRef}
<               virtualScroll={virtualScroll}
<               enteredTextLabel={i18nStrings.enteredTextLabel}
<               ariaLabel={filteringAriaLabel ?? i18nStrings.filteringAriaLabel}
<               placeholder={
<                 filteringPlaceholder ?? i18nStrings.filteringPlaceholder
---
>         const loadMoreDetail = getLoadMoreDetail(parsedText, filteringText)
>         const inputLoadItemsHandlers = useLoadItems(
>           onLoadItems,
>           loadMoreDetail.filteringText,
>           loadMoreDetail.filteringProperty,
>           loadMoreDetail.filteringText,
>           loadMoreDetail.filteringOperator
>         )
>         const asyncProps = {
>           empty: filteringEmpty,
>           loadingText: filteringLoadingText,
>           finishedText: filteringFinishedText,
>           errorText: filteringErrorText,
>           recoveryText: filteringRecoveryText,
>           statusType: filteringStatusType
>         }
>         const asyncAutosuggestProps =
>           !!filteringText.length || asyncProperties
>             ? {
>                 ...inputLoadItemsHandlers,
>                 ...asyncProps
442,471c392,538
<               ariaLabelledby={rest.ariaLabelledby}
<               ariaDescribedby={rest.ariaDescribedby}
<               controlId={rest.controlId}
<               value={filteringText}
<               disabled={disabled}
<               onKeyDown={handleKeyDown}
<               {...autosuggestOptions}
<               onChange={event => setFilteringText(event.detail.value)}
<               empty={filteringEmpty}
<               {...asyncAutosuggestProps}
<               expandToViewport={expandToViewport}
<               onOptionClick={handleSelected}
<               customForm={
<                 operatorForm && (
<                   <PropertyEditor
<                     property={parsedText.property}
<                     operator={parsedText.operator}
<                     filter={parsedText.value}
<                     operatorForm={operatorForm}
<                     i18nStrings={i18nStrings}
<                     onCancel={() => {
<                       setFilteringText('')
<                       inputRef.current?.close()
<                       inputRef.current?.focus({preventDropdown: true})
<                     }}
<                     onSubmit={token => {
<                       addToken(token)
<                       setFilteringText('')
<                       inputRef.current?.focus({preventDropdown: true})
<                       inputRef.current?.close()
---
>             : {}
>         const handleSelected = event => {
>           ignoreKeyDown.current = true
>           setTimeout(() => {
>             ignoreKeyDown.current = false
>           }, 0)
>           const {detail: option} = event
>           const value = option.value || ''
>           if (!('keepOpenOnSelect' in option)) {
>             createToken(value)
>             return
>           }
>           event.preventDefault()
>           const parsedText2 = parseText(
>             value,
>             internalProperties,
>             internalFreeText
>           )
>           const loadMoreDetail2 = getLoadMoreDetail(parsedText2, value)
>           if (parsedText2.step === 'operator') {
>             const operators = getAllowedOperators(parsedText2.property)
>             if (
>               value.trim() === parsedText2.property.propertyLabel &&
>               operators.length === 1
>             ) {
>               loadMoreDetail2.filteringProperty =
>                 parsedText2.property.externalProperty ?? void 0
>               loadMoreDetail2.filteringOperator = operators[0]
>               loadMoreDetail2.filteringText = ''
>               setFilteringText(
>                 parsedText2.property.propertyLabel + ' ' + operators[0] + ' '
>               )
>             }
>           }
>           fireNonCancelableEvent(onLoadItems, {
>             ...loadMoreDetail2,
>             firstPage: true,
>             samePage: false
>           })
>         }
>         const operatorForm =
>           parsedText.step === 'property' &&
>           parsedText.property.getValueFormRenderer(parsedText.operator)
>         const searchResultsId = useUniqueId('property-filter-search-results')
>         return (
>           <div
>             {...baseProps}
>             className={clsx(baseProps.className, styles.root)}
>             ref={__internalRootRef}>
>             <div className={styles['search-field']}>
>               {customControl && (
>                 <div className={styles['custom-control']}>{customControl}</div>
>               )}
>               <PropertyFilterAutosuggest
>                 ref={inputRef}
>                 virtualScroll={virtualScroll}
>                 enteredTextLabel={i18nStrings.enteredTextLabel}
>                 ariaLabel={
>                   filteringAriaLabel ?? i18nStrings.filteringAriaLabel
>                 }
>                 placeholder={
>                   filteringPlaceholder ?? i18nStrings.filteringPlaceholder
>                 }
>                 ariaLabelledby={rest.ariaLabelledby}
>                 ariaDescribedby={rest.ariaDescribedby}
>                 controlId={rest.controlId}
>                 value={filteringText}
>                 disabled={disabled}
>                 onKeyDown={handleKeyDown}
>                 {...autosuggestOptions}
>                 onChange={event => setFilteringText(event.detail.value)}
>                 empty={filteringEmpty}
>                 {...asyncAutosuggestProps}
>                 expandToViewport={expandToViewport}
>                 onOptionClick={handleSelected}
>                 customForm={
>                   operatorForm && (
>                     <PropertyEditor
>                       property={parsedText.property}
>                       operator={parsedText.operator}
>                       filter={parsedText.value}
>                       operatorForm={operatorForm}
>                       i18nStrings={i18nStrings}
>                       onCancel={() => {
>                         setFilteringText('')
>                         inputRef.current?.close()
>                         inputRef.current?.focus({preventDropdown: true})
>                       }}
>                       onSubmit={token => {
>                         addToken(token)
>                         setFilteringText('')
>                         inputRef.current?.focus({preventDropdown: true})
>                         inputRef.current?.close()
>                       }}
>                     />
>                   )
>                 }
>                 hideEnteredTextOption={
>                   internalFreeText.disabled && parsedText.step !== 'property'
>                 }
>                 clearAriaLabel={i18nStrings.clearAriaLabel}
>                 searchResultsId={showResults ? searchResultsId : void 0}
>               />
>               {showResults ? (
>                 <div className={styles.results}>
>                   <SearchResults id={searchResultsId}>
>                     {countText}
>                   </SearchResults>
>                 </div>
>               ) : null}
>             </div>
>             {internalQuery.tokens && internalQuery.tokens.length > 0 && (
>               <div className={styles.tokens}>
>                 <InternalSpaceBetween size='xs' direction='horizontal'>
>                   <TokenList
>                     alignment='inline'
>                     limit={tokenLimit}
>                     items={internalQuery.tokens}
>                     limitShowFewerAriaLabel={tokenLimitShowFewerAriaLabel}
>                     limitShowMoreAriaLabel={tokenLimitShowMoreAriaLabel}
>                     renderItem={(token, tokenIndex) => (
>                       <TokenButton
>                         token={token}
>                         first={tokenIndex === 0}
>                         operation={internalQuery.operation}
>                         removeToken={() => {
>                           removeToken(tokenIndex)
>                           setRemovedTokenIndex(tokenIndex)
>                         }}
>                         setToken={newToken => setToken(tokenIndex, newToken)}
>                         setOperation={setOperation}
>                         filteringProperties={internalProperties}
>                         filteringOptions={internalOptions}
>                         asyncProps={asyncProps}
>                         onLoadItems={onLoadItems}
>                         i18nStrings={i18nStrings}
>                         asyncProperties={asyncProperties}
>                         hideOperations={hideOperations}
>                         customGroupsText={customGroupsText}
>                         freeTextFiltering={internalFreeText}
>                         disabled={disabled}
>                         expandToViewport={expandToViewport}
>                       />
>                     )}
>                     i18nStrings={{
>                       limitShowFewer: i18nStrings.tokenLimitShowFewer,
>                       limitShowMore: i18nStrings.tokenLimitShowMore
472a540,555
>                     after={
>                       customFilterActions ? (
>                         <div className={styles['custom-filter-actions']}>
>                           {customFilterActions}
>                         </div>
>                       ) : (
>                         <InternalButton
>                           formAction='none'
>                           onClick={removeAllTokens}
>                           className={styles['remove-all']}
>                           disabled={disabled}>
>                           {i18nStrings.clearFiltersText}
>                         </InternalButton>
>                       )
>                     }
>                     moveFocusNextToIndex={removedTokenIndex}
474,484c557
<                 )
<               }
<               hideEnteredTextOption={
<                 internalFreeText.disabled && parsedText.step !== 'property'
<               }
<               clearAriaLabel={i18nStrings.clearAriaLabel}
<               searchResultsId={showResults ? searchResultsId : void 0}
<             />
<             {showResults ? (
<               <div className={styles.results}>
<                 <SearchResults id={searchResultsId}>{countText}</SearchResults>
---
>                 </InternalSpaceBetween>
486c559
<             ) : null}
---
>             )}
488,547c561,563
<           {internalQuery.tokens && internalQuery.tokens.length > 0 && (
<             <div className={styles.tokens}>
<               <InternalSpaceBetween size='xs' direction='horizontal'>
<                 <TokenList
<                   alignment='inline'
<                   limit={tokenLimit}
<                   items={internalQuery.tokens}
<                   limitShowFewerAriaLabel={tokenLimitShowFewerAriaLabel}
<                   limitShowMoreAriaLabel={tokenLimitShowMoreAriaLabel}
<                   renderItem={(token, tokenIndex) => (
<                     <TokenButton
<                       token={token}
<                       first={tokenIndex === 0}
<                       operation={internalQuery.operation}
<                       removeToken={() => {
<                         removeToken(tokenIndex)
<                         setRemovedTokenIndex(tokenIndex)
<                       }}
<                       setToken={newToken => setToken(tokenIndex, newToken)}
<                       setOperation={setOperation}
<                       filteringProperties={internalProperties}
<                       filteringOptions={internalOptions}
<                       asyncProps={asyncProps}
<                       onLoadItems={onLoadItems}
<                       i18nStrings={i18nStrings}
<                       asyncProperties={asyncProperties}
<                       hideOperations={hideOperations}
<                       customGroupsText={customGroupsText}
<                       freeTextFiltering={internalFreeText}
<                       disabled={disabled}
<                       expandToViewport={expandToViewport}
<                     />
<                   )}
<                   i18nStrings={{
<                     limitShowFewer: i18nStrings.tokenLimitShowFewer,
<                     limitShowMore: i18nStrings.tokenLimitShowMore
<                   }}
<                   after={
<                     customFilterActions ? (
<                       <div className={styles['custom-filter-actions']}>
<                         {customFilterActions}
<                       </div>
<                     ) : (
<                       <InternalButton
<                         formAction='none'
<                         onClick={removeAllTokens}
<                         className={styles['remove-all']}
<                         disabled={disabled}>
<                         {i18nStrings.clearFiltersText}
<                       </InternalButton>
<                     )
<                   }
<                   moveFocusNextToIndex={removedTokenIndex}
<                 />
<               </InternalSpaceBetween>
<             </div>
<           )}
<         </div>
<       )
<     }
---
>         )
>       }
>     )
diff -r src/components/radio-group/internal.jsx ../cloudcomp/lib/components/radio-group/internal.jsx
46,59c46,61
<             items.map((item, index) => (
<               <RadioButton
<                 key={item.value}
<                 ref={index === radioButtonRefIndex ? radioButtonRef : void 0}
<                 checked={item.value === value}
<                 name={name || generatedName}
<                 value={item.value}
<                 label={item.label}
<                 description={item.description}
<                 disabled={item.disabled}
<                 onChange={onChange}
<                 controlId={item.controlId}
<               />
<             ))}
---
>             memo(
>               items.map((item, index) => (
>                 <RadioButton
>                   key={item.value}
>                   ref={index === radioButtonRefIndex ? radioButtonRef : void 0}
>                   checked={item.value === value}
>                   name={name || generatedName}
>                   value={item.value}
>                   label={item.label}
>                   description={item.description}
>                   disabled={item.disabled}
>                   onChange={onChange}
>                   controlId={item.controlId}
>                 />
>               ))
>             )}
diff -r src/components/segmented-control/internal-segmented-control.jsx ../cloudcomp/lib/components/segmented-control/internal-segmented-control.jsx
45,68c45,81
<           options.map((option, index) => {
<             const isActive = selectedId === option.id
<             const enabledSegmentIndex = enabledSegments.indexOf(option)
<             let tabIndex = isActive ? 0 : -1
<             if (currentSelectedOption === null && enabledSegmentIndex === 0) {
<               tabIndex = 0
<             }
<             return (
<               <Segment
<                 key={index}
<                 id={option.id}
<                 disabled={!!option.disabled}
<                 iconName={option.iconName}
<                 iconAlt={option.iconAlt}
<                 iconUrl={option.iconUrl}
<                 iconSvg={option.iconSvg}
<                 text={option.text}
<                 isActive={isActive}
<                 tabIndex={tabIndex}
<                 ref={node => {
<                   if (node) {
<                     segmentByIdRef.current[option.id] = node
<                   } else {
<                     delete segmentByIdRef.current[option.id]
---
>           options.map(
>             memo((option, index) => {
>               const isActive = selectedId === option.id
>               const enabledSegmentIndex = enabledSegments.indexOf(option)
>               let tabIndex = isActive ? 0 : -1
>               if (
>                 currentSelectedOption === null &&
>                 enabledSegmentIndex === 0
>               ) {
>                 tabIndex = 0
>               }
>               return (
>                 <Segment
>                   key={index}
>                   id={option.id}
>                   disabled={!!option.disabled}
>                   iconName={option.iconName}
>                   iconAlt={option.iconAlt}
>                   iconUrl={option.iconUrl}
>                   iconSvg={option.iconSvg}
>                   text={option.text}
>                   isActive={isActive}
>                   tabIndex={tabIndex}
>                   ref={node => {
>                     if (node) {
>                       segmentByIdRef.current[option.id] = node
>                     } else {
>                       delete segmentByIdRef.current[option.id]
>                     }
>                   }}
>                   onClick={() => {
>                     if (selectedId !== option.id) {
>                       fireNonCancelableEvent(onChange, {selectedId: option.id})
>                     }
>                   }}
>                   onKeyDown={event =>
>                     moveHighlight(event, enabledSegmentIndex)
70,79c83,86
<                 }}
<                 onClick={() => {
<                   if (selectedId !== option.id) {
<                     fireNonCancelableEvent(onChange, {selectedId: option.id})
<                   }
<                 }}
<                 onKeyDown={event => moveHighlight(event, enabledSegmentIndex)}
<               />
<             )
<           })}
---
>                 />
>               )
>             })
>           )}
diff -r src/components/select/parts/trigger.jsx ../cloudcomp/lib/components/select/parts/trigger.jsx
46,50c46,52
<                 {selectedOptions.map(({label}, i) => (
<                   <span key={i} className={styles['inline-token']}>
<                     {label}
<                   </span>
<                 ))}
---
>                 {memo(
>                   selectedOptions.map(({label}, i) => (
>                     <span key={i} className={styles['inline-token']}>
>                       {label}
>                     </span>
>                   ))
>                 )}
diff -r src/components/select/utils/render-options.jsx ../cloudcomp/lib/components/select/utils/render-options.jsx
0a1
> import {memo} from 'react'
5,41c6,46
< const renderOptions = ({
<   options,
<   getOptionProps,
<   filteringValue,
<   highlightType,
<   checkboxes = false,
<   hasDropdownStatus,
<   virtualItems,
<   useInteractiveGroups,
<   screenReaderContent,
<   ariaSetsize
< }) => {
<   return options.map((option, index) => {
<     const virtualItem = virtualItems && virtualItems[index]
<     const globalIndex = virtualItem ? virtualItem.index : index
<     const props = getItemProps({
<       option,
<       index: globalIndex,
<       getOptionProps,
<       filteringValue,
<       checkboxes
<     })
<     const isLastItem = index === options.length - 1
<     const padBottom = !hasDropdownStatus && isLastItem
<     const ListItem = useInteractiveGroups ? MutliselectItem : Item
<     return (
<       <ListItem
<         key={globalIndex}
<         {...props}
<         virtualPosition={virtualItem && virtualItem.start}
<         ref={virtualItem && virtualItem.measureRef}
<         padBottom={padBottom}
<         screenReaderContent={screenReaderContent}
<         ariaPosinset={globalIndex + 1}
<         ariaSetsize={ariaSetsize}
<         highlightType={highlightType.type}
<       />
---
> const renderOptions = memo(
>   ({
>     options,
>     getOptionProps,
>     filteringValue,
>     highlightType,
>     checkboxes = false,
>     hasDropdownStatus,
>     virtualItems,
>     useInteractiveGroups,
>     screenReaderContent,
>     ariaSetsize
>   }) => {
>     return options.map(
>       memo((option, index) => {
>         const virtualItem = virtualItems && virtualItems[index]
>         const globalIndex = virtualItem ? virtualItem.index : index
>         const props = getItemProps({
>           option,
>           index: globalIndex,
>           getOptionProps,
>           filteringValue,
>           checkboxes
>         })
>         const isLastItem = index === options.length - 1
>         const padBottom = !hasDropdownStatus && isLastItem
>         const ListItem = useInteractiveGroups ? MutliselectItem : Item
>         return (
>           <ListItem
>             key={globalIndex}
>             {...props}
>             virtualPosition={virtualItem && virtualItem.start}
>             ref={virtualItem && virtualItem.measureRef}
>             padBottom={padBottom}
>             screenReaderContent={screenReaderContent}
>             ariaPosinset={globalIndex + 1}
>             ariaSetsize={ariaSetsize}
>             highlightType={highlightType.type}
>           />
>         )
>       })
43,44c48,49
<   })
< }
---
>   }
> )
diff -r src/components/side-navigation/internal.jsx ../cloudcomp/lib/components/side-navigation/internal.jsx
55,70c55,165
<     items.forEach((item, index) => {
<       const itemid = index + 1
<       switch (item.type) {
<         case 'divider': {
<           const dividerIndex = lists.length
<           lists[dividerIndex] = {
<             element: (
<               <div data-itemid={`item-${itemid}`}>
<                 <Divider variant='default' />
<               </div>
<             )
<           }
<           currentListIndex = lists.length
<           lists[currentListIndex] = {
<             listVariant: variant,
<             items: []
---
>     items.forEach(
>       memo((item, index) => {
>         const itemid = index + 1
>         switch (item.type) {
>           case 'divider': {
>             const dividerIndex = lists.length
>             lists[dividerIndex] = {
>               element: (
>                 <div data-itemid={`item-${itemid}`}>
>                   <Divider variant='default' />
>                 </div>
>               )
>             }
>             currentListIndex = lists.length
>             lists[currentListIndex] = {
>               listVariant: variant,
>               items: []
>             }
>             return
>           }
>           case 'link': {
>             lists[currentListIndex].items?.push({
>               element: (
>                 <li
>                   key={index}
>                   data-itemid={`item-${itemid}`}
>                   className={styles['list-item']}>
>                   <XinK
>                     definition={item}
>                     activeHref={activeHref}
>                     fireChange={fireChange}
>                     fireFollow={fireFollow}
>                   />
>                 </li>
>               )
>             })
>             return
>           }
>           case 'section': {
>             lists[currentListIndex].items?.push({
>               element: (
>                 <li
>                   key={index}
>                   data-itemid={`item-${itemid}`}
>                   className={styles['list-item']}>
>                   <Section
>                     definition={item}
>                     activeHref={activeHref}
>                     variant={variant}
>                     fireChange={fireChange}
>                     fireFollow={fireFollow}
>                   />
>                 </li>
>               )
>             })
>             return
>           }
>           case 'section-group': {
>             lists[currentListIndex].items?.push({
>               element: (
>                 <li
>                   key={index}
>                   data-itemid={`item-${itemid}`}
>                   className={styles['list-item']}>
>                   <SectionGroup
>                     definition={item}
>                     activeHref={activeHref}
>                     fireChange={fireChange}
>                     fireFollow={fireFollow}
>                   />
>                 </li>
>               )
>             })
>             return
>           }
>           case 'link-group': {
>             lists[currentListIndex].items?.push({
>               element: (
>                 <li
>                   key={index}
>                   data-itemid={`item-${itemid}`}
>                   className={styles['list-item']}>
>                   <LinkGroup
>                     definition={item}
>                     activeHref={activeHref}
>                     fireChange={fireChange}
>                     fireFollow={fireFollow}
>                   />
>                 </li>
>               )
>             })
>             return
>           }
>           case 'expandable-link-group': {
>             lists[currentListIndex].items?.push({
>               element: (
>                 <li
>                   key={index}
>                   data-itemid={`item-${itemid}`}
>                   className={styles['list-item']}>
>                   <ExpandableLinkGroup
>                     definition={item}
>                     activeHref={activeHref}
>                     fireChange={fireChange}
>                     fireFollow={fireFollow}
>                     variant={variant}
>                   />
>                 </li>
>               )
>             })
>             return
72,164d166
<           return
<         }
<         case 'link': {
<           lists[currentListIndex].items?.push({
<             element: (
<               <li
<                 key={index}
<                 data-itemid={`item-${itemid}`}
<                 className={styles['list-item']}>
<                 <XinK
<                   definition={item}
<                   activeHref={activeHref}
<                   fireChange={fireChange}
<                   fireFollow={fireFollow}
<                 />
<               </li>
<             )
<           })
<           return
<         }
<         case 'section': {
<           lists[currentListIndex].items?.push({
<             element: (
<               <li
<                 key={index}
<                 data-itemid={`item-${itemid}`}
<                 className={styles['list-item']}>
<                 <Section
<                   definition={item}
<                   activeHref={activeHref}
<                   variant={variant}
<                   fireChange={fireChange}
<                   fireFollow={fireFollow}
<                 />
<               </li>
<             )
<           })
<           return
<         }
<         case 'section-group': {
<           lists[currentListIndex].items?.push({
<             element: (
<               <li
<                 key={index}
<                 data-itemid={`item-${itemid}`}
<                 className={styles['list-item']}>
<                 <SectionGroup
<                   definition={item}
<                   activeHref={activeHref}
<                   fireChange={fireChange}
<                   fireFollow={fireFollow}
<                 />
<               </li>
<             )
<           })
<           return
<         }
<         case 'link-group': {
<           lists[currentListIndex].items?.push({
<             element: (
<               <li
<                 key={index}
<                 data-itemid={`item-${itemid}`}
<                 className={styles['list-item']}>
<                 <LinkGroup
<                   definition={item}
<                   activeHref={activeHref}
<                   fireChange={fireChange}
<                   fireFollow={fireFollow}
<                 />
<               </li>
<             )
<           })
<           return
<         }
<         case 'expandable-link-group': {
<           lists[currentListIndex].items?.push({
<             element: (
<               <li
<                 key={index}
<                 data-itemid={`item-${itemid}`}
<                 className={styles['list-item']}>
<                 <ExpandableLinkGroup
<                   definition={item}
<                   activeHref={activeHref}
<                   fireChange={fireChange}
<                   fireFollow={fireFollow}
<                   variant={variant}
<                 />
<               </li>
<             )
<           })
<           return
166,167c168,169
<       }
<     })
---
>       })
>     )
171,203c173,207
<         {lists.map((list, index) => {
<           if (!list.items || list.items.length === 0) {
<             return (
<               <div
<                 key={`hr-${index}`}
<                 className={clsx(
<                   styles.list,
<                   styles[`list-variant-${variant}`],
<                   {
<                     [styles['list-variant-root--last']]:
<                       list.listVariant === 'root' && index === lastListIndex
<                   }
<                 )}>
<                 {list.element}
<               </div>
<             )
<           } else {
<             return (
<               <ul
<                 key={`list-${index}`}
<                 className={clsx(
<                   styles.list,
<                   styles[`list-variant-${list.listVariant}`],
<                   {
<                     [styles['list-variant-root--last']]:
<                       list.listVariant === 'root' && index === lastListIndex
<                   }
<                 )}>
<                 {list.items.map(item => item.element)}
<               </ul>
<             )
<           }
<         })}
---
>         {lists.map(
>           memo((list, index) => {
>             if (!list.items || list.items.length === 0) {
>               return (
>                 <div
>                   key={`hr-${index}`}
>                   className={clsx(
>                     styles.list,
>                     styles[`list-variant-${variant}`],
>                     {
>                       [styles['list-variant-root--last']]:
>                         list.listVariant === 'root' && index === lastListIndex
>                     }
>                   )}>
>                   {list.element}
>                 </div>
>               )
>             } else {
>               return (
>                 <ul
>                   key={`list-${index}`}
>                   className={clsx(
>                     styles.list,
>                     styles[`list-variant-${list.listVariant}`],
>                     {
>                       [styles['list-variant-root--last']]:
>                         list.listVariant === 'root' && index === lastListIndex
>                     }
>                   )}>
>                   {list.items.map(item => item.element)}
>                 </ul>
>               )
>             }
>           })
>         )}
diff -r src/components/space-between/internal.jsx ../cloudcomp/lib/components/space-between/internal.jsx
29,36c29,38
<         {flattenedChildren.map(child => {
<           const key = typeof child === 'object' ? child.key : void 0
<           return (
<             <div key={key} className={styles.child}>
<               {child}
<             </div>
<           )
<         })}
---
>         {flattenedChildren.map(
>           memo(child => {
>             const key = typeof child === 'object' ? child.key : void 0
>             return (
>               <div key={key} className={styles.child}>
>                 {child}
>               </div>
>             )
>           })
>         )}
diff -r src/components/split-panel/implementation.jsx ../cloudcomp/lib/components/split-panel/implementation.jsx
21,91c21,108
<   forwardRef(
<     (
<       {
<         header,
<         children,
<         hidePreferencesButton = false,
<         closeBehavior = 'collapse',
<         i18nStrings,
<         ...restProps
<       },
<       __internalRootRef
<     ) => {
<       const isRefresh = useVisualRefresh()
<       const {
<         position,
<         topOffset,
<         bottomOffset,
<         rightOffset,
<         contentWidthStyles,
<         isOpen,
<         isForcedPosition,
<         onPreferencesChange,
<         onResize,
<         onToggle,
<         size,
<         relativeSize,
<         setSplitPanelToggle,
<         refs
<       } = useSplitPanelContext()
<       const baseProps = getBaseProps(restProps)
<       const i18n = useInternalI18n('split-panel')
<       const [isPreferencesOpen, setPreferencesOpen] = useState(false)
<       const appLayoutMaxWidth =
<         isRefresh && position === 'bottom' ? contentWidthStyles : void 0
<       const openButtonAriaLabel = i18n(
<         'i18nStrings.openButtonAriaLabel',
<         i18nStrings?.openButtonAriaLabel
<       )
<       useEffect(() => {
<         setSplitPanelToggle({
<           displayed: closeBehavior === 'collapse',
<           ariaLabel: openButtonAriaLabel
<         })
<       }, [setSplitPanelToggle, openButtonAriaLabel, closeBehavior])
<       const splitPanelRefObject = useRef(null)
<       const sizeControlProps = {
<         position,
<         panelRef: splitPanelRefObject,
<         handleRef: refs.slider,
<         onResize
<       }
<       const onSliderPointerDown = usePointerEvents(sizeControlProps)
<       const onKeyDown = useKeyboardEvents(sizeControlProps)
<       const wrappedChildren = (
<         <AppLayoutContext.Provider
<           value={{
<             stickyOffsetTop: topOffset,
<             stickyOffsetBottom: bottomOffset
<           }}>
<           {children}
<         </AppLayoutContext.Provider>
<       )
<       const panelHeaderId = useUniqueId('split-panel-header')
<       const wrappedHeader = (
<         <div className={styles.header} style={appLayoutMaxWidth}>
<           <h2 className={styles['header-text']} id={panelHeaderId}>
<             {header}
<           </h2>
<           <div className={styles['header-actions']}>
<             {!hidePreferencesButton && isOpen && (
<               <>
---
>   memo(
>     forwardRef(
>       (
>         {
>           header,
>           children,
>           hidePreferencesButton = false,
>           closeBehavior = 'collapse',
>           i18nStrings,
>           ...restProps
>         },
>         __internalRootRef
>       ) => {
>         const isRefresh = useVisualRefresh()
>         const {
>           position,
>           topOffset,
>           bottomOffset,
>           rightOffset,
>           contentWidthStyles,
>           isOpen,
>           isForcedPosition,
>           onPreferencesChange,
>           onResize,
>           onToggle,
>           size,
>           relativeSize,
>           setSplitPanelToggle,
>           refs
>         } = useSplitPanelContext()
>         const baseProps = getBaseProps(restProps)
>         const i18n = useInternalI18n('split-panel')
>         const [isPreferencesOpen, setPreferencesOpen] = useState(false)
>         const appLayoutMaxWidth =
>           isRefresh && position === 'bottom' ? contentWidthStyles : void 0
>         const openButtonAriaLabel = i18n(
>           'i18nStrings.openButtonAriaLabel',
>           i18nStrings?.openButtonAriaLabel
>         )
>         useEffect(() => {
>           setSplitPanelToggle({
>             displayed: closeBehavior === 'collapse',
>             ariaLabel: openButtonAriaLabel
>           })
>         }, [setSplitPanelToggle, openButtonAriaLabel, closeBehavior])
>         const splitPanelRefObject = useRef(null)
>         const sizeControlProps = {
>           position,
>           panelRef: splitPanelRefObject,
>           handleRef: refs.slider,
>           onResize
>         }
>         const onSliderPointerDown = usePointerEvents(sizeControlProps)
>         const onKeyDown = useKeyboardEvents(sizeControlProps)
>         const wrappedChildren = (
>           <AppLayoutContext.Provider
>             value={{
>               stickyOffsetTop: topOffset,
>               stickyOffsetBottom: bottomOffset
>             }}>
>             {children}
>           </AppLayoutContext.Provider>
>         )
>         const panelHeaderId = useUniqueId('split-panel-header')
>         const wrappedHeader = (
>           <div className={styles.header} style={appLayoutMaxWidth}>
>             <h2 className={styles['header-text']} id={panelHeaderId}>
>               {header}
>             </h2>
>             <div className={styles['header-actions']}>
>               {!hidePreferencesButton && isOpen && (
>                 <>
>                   <InternalButton
>                     className={styles['preferences-button']}
>                     iconName='settings'
>                     variant='icon'
>                     onClick={() => setPreferencesOpen(true)}
>                     formAction='none'
>                     ariaLabel={i18n(
>                       'i18nStrings.preferencesTitle',
>                       i18nStrings?.preferencesTitle
>                     )}
>                     ref={refs.preferences}
>                   />
>                   <span className={styles.divider} />
>                 </>
>               )}
>               {isOpen ? (
93,94c110,117
<                   className={styles['preferences-button']}
<                   iconName='settings'
---
>                   className={styles['close-button']}
>                   iconName={
>                     isRefresh && closeBehavior === 'collapse'
>                       ? position === 'side'
>                         ? 'angle-right'
>                         : 'angle-down'
>                       : 'close'
>                   }
96c119
<                   onClick={() => setPreferencesOpen(true)}
---
>                   onClick={onToggle}
99,100c122,123
<                     'i18nStrings.preferencesTitle',
<                     i18nStrings?.preferencesTitle
---
>                     'i18nStrings.closeButtonAriaLabel',
>                     i18nStrings?.closeButtonAriaLabel
102c125
<                   ref={refs.preferences}
---
>                   ariaExpanded={isOpen}
104,198c127,133
<                 <span className={styles.divider} />
<               </>
<             )}
<             {isOpen ? (
<               <InternalButton
<                 className={styles['close-button']}
<                 iconName={
<                   isRefresh && closeBehavior === 'collapse'
<                     ? position === 'side'
<                       ? 'angle-right'
<                       : 'angle-down'
<                     : 'close'
<                 }
<                 variant='icon'
<                 onClick={onToggle}
<                 formAction='none'
<                 ariaLabel={i18n(
<                   'i18nStrings.closeButtonAriaLabel',
<                   i18nStrings?.closeButtonAriaLabel
<                 )}
<                 ariaExpanded={isOpen}
<               />
<             ) : position === 'side' ? null : (
<               <InternalButton
<                 className={styles['open-button']}
<                 iconName='angle-up'
<                 variant='icon'
<                 formAction='none'
<                 ariaLabel={i18n(
<                   'i18nStrings.openButtonAriaLabel',
<                   i18nStrings?.openButtonAriaLabel
<                 )}
<                 ref={refs.toggle}
<                 ariaExpanded={isOpen}
<               />
<             )}
<           </div>
<         </div>
<       )
<       const resizeHandle = (
<         <div
<           ref={refs.slider}
<           role='slider'
<           tabIndex={0}
<           aria-label={i18n(
<             'i18nStrings.resizeHandleAriaLabel',
<             i18nStrings?.resizeHandleAriaLabel
<           )}
<           aria-valuemax={100}
<           aria-valuemin={0}
<           aria-valuenow={
<             position === 'bottom' ? relativeSize : 100 - relativeSize
<           }
<           className={clsx(styles.slider, styles[`slider-${position}`])}
<           onKeyDown={onKeyDown}
<           onPointerDown={onSliderPointerDown}>
<           <ResizeHandler
<             className={clsx(
<               styles['slider-icon'],
<               styles[`slider-icon-${position}`]
<             )}
<           />
<         </div>
<       )
<       useEffect(() => {
<         const root = splitPanelRefObject.current
<         if (root) {
<           const property = 'transform'
<           const temporaryValue = 'translateZ(0)'
<           const valueBefore = root.style[property]
<           root.style[property] = temporaryValue
<           void root.offsetHeight
<           root.style[property] = valueBefore
<         }
<       }, [rightOffset, __internalRootRef])
<       const mergedRef = useMergeRefs(splitPanelRefObject, __internalRootRef)
<       if (closeBehavior === 'hide' && !isOpen) {
<         return <></>
<       }
<       if (isRefresh && !isOpen && position === 'side') {
<         return <></>
<       }
<       return (
<         <Transition in={isOpen ?? false}>
<           {(state, transitioningElementRef) => (
<             <>
<               {position === 'side' && (
<                 <SplitPanelContentSide
<                   resizeHandle={resizeHandle}
<                   baseProps={baseProps}
<                   isOpen={isOpen}
<                   splitPanelRef={mergedRef}
<                   cappedSize={size}
<                   onToggle={onToggle}
<                   openButtonAriaLabel={i18n(
---
>               ) : position === 'side' ? null : (
>                 <InternalButton
>                   className={styles['open-button']}
>                   iconName='angle-up'
>                   variant='icon'
>                   formAction='none'
>                   ariaLabel={i18n(
202,268c137,138
<                   toggleRef={refs.toggle}
<                   header={wrappedHeader}
<                   panelHeaderId={panelHeaderId}>
<                   {wrappedChildren}
<                 </SplitPanelContentSide>
<               )}
<               {position === 'bottom' && (
<                 <SplitPanelContentBottom
<                   resizeHandle={resizeHandle}
<                   baseProps={baseProps}
<                   isOpen={isOpen}
<                   splitPanelRef={mergedRef}
<                   cappedSize={size}
<                   onToggle={onToggle}
<                   header={wrappedHeader}
<                   panelHeaderId={panelHeaderId}
<                   state={state}
<                   transitioningElementRef={transitioningElementRef}
<                   appLayoutMaxWidth={appLayoutMaxWidth}>
<                   {wrappedChildren}
<                 </SplitPanelContentBottom>
<               )}
<               {isPreferencesOpen && (
<                 <PreferencesModal
<                   visible={true}
<                   preferences={{position}}
<                   disabledSidePosition={
<                     position === 'bottom' && isForcedPosition
<                   }
<                   isRefresh={isRefresh}
<                   i18nStrings={{
<                     header: i18n(
<                       'i18nStrings.preferencesTitle',
<                       i18nStrings?.preferencesTitle
<                     ),
<                     confirm: i18n(
<                       'i18nStrings.preferencesConfirm',
<                       i18nStrings?.preferencesConfirm
<                     ),
<                     cancel: i18n(
<                       'i18nStrings.preferencesCancel',
<                       i18nStrings?.preferencesCancel
<                     ),
<                     positionLabel: i18n(
<                       'i18nStrings.preferencesPositionLabel',
<                       i18nStrings?.preferencesPositionLabel
<                     ),
<                     positionDescription: i18n(
<                       'i18nStrings.preferencesPositionDescription',
<                       i18nStrings?.preferencesPositionDescription
<                     ),
<                     positionBottom: i18n(
<                       'i18nStrings.preferencesPositionBottom',
<                       i18nStrings?.preferencesPositionBottom
<                     ),
<                     positionSide: i18n(
<                       'i18nStrings.preferencesPositionSide',
<                       i18nStrings?.preferencesPositionSide
<                     )
<                   }}
<                   onConfirm={preferences => {
<                     onPreferencesChange({...preferences})
<                     setPreferencesOpen(false)
<                   }}
<                   onDismiss={() => {
<                     setPreferencesOpen(false)
<                   }}
---
>                   ref={refs.toggle}
>                   ariaExpanded={isOpen}
271,275c141,277
<             </>
<           )}
<         </Transition>
<       )
<     }
---
>             </div>
>           </div>
>         )
>         const resizeHandle = (
>           <div
>             ref={refs.slider}
>             role='slider'
>             tabIndex={0}
>             aria-label={i18n(
>               'i18nStrings.resizeHandleAriaLabel',
>               i18nStrings?.resizeHandleAriaLabel
>             )}
>             aria-valuemax={100}
>             aria-valuemin={0}
>             aria-valuenow={
>               position === 'bottom' ? relativeSize : 100 - relativeSize
>             }
>             className={clsx(styles.slider, styles[`slider-${position}`])}
>             onKeyDown={onKeyDown}
>             onPointerDown={onSliderPointerDown}>
>             <ResizeHandler
>               className={clsx(
>                 styles['slider-icon'],
>                 styles[`slider-icon-${position}`]
>               )}
>             />
>           </div>
>         )
>         useEffect(() => {
>           const root = splitPanelRefObject.current
>           if (root) {
>             const property = 'transform'
>             const temporaryValue = 'translateZ(0)'
>             const valueBefore = root.style[property]
>             root.style[property] = temporaryValue
>             void root.offsetHeight
>             root.style[property] = valueBefore
>           }
>         }, [rightOffset, __internalRootRef])
>         const mergedRef = useMergeRefs(splitPanelRefObject, __internalRootRef)
>         if (closeBehavior === 'hide' && !isOpen) {
>           return <></>
>         }
>         if (isRefresh && !isOpen && position === 'side') {
>           return <></>
>         }
>         return (
>           <Transition in={isOpen ?? false}>
>             {(state, transitioningElementRef) => (
>               <>
>                 {position === 'side' && (
>                   <SplitPanelContentSide
>                     resizeHandle={resizeHandle}
>                     baseProps={baseProps}
>                     isOpen={isOpen}
>                     splitPanelRef={mergedRef}
>                     cappedSize={size}
>                     onToggle={onToggle}
>                     openButtonAriaLabel={i18n(
>                       'i18nStrings.openButtonAriaLabel',
>                       i18nStrings?.openButtonAriaLabel
>                     )}
>                     toggleRef={refs.toggle}
>                     header={wrappedHeader}
>                     panelHeaderId={panelHeaderId}>
>                     {wrappedChildren}
>                   </SplitPanelContentSide>
>                 )}
>                 {position === 'bottom' && (
>                   <SplitPanelContentBottom
>                     resizeHandle={resizeHandle}
>                     baseProps={baseProps}
>                     isOpen={isOpen}
>                     splitPanelRef={mergedRef}
>                     cappedSize={size}
>                     onToggle={onToggle}
>                     header={wrappedHeader}
>                     panelHeaderId={panelHeaderId}
>                     state={state}
>                     transitioningElementRef={transitioningElementRef}
>                     appLayoutMaxWidth={appLayoutMaxWidth}>
>                     {wrappedChildren}
>                   </SplitPanelContentBottom>
>                 )}
>                 {isPreferencesOpen && (
>                   <PreferencesModal
>                     visible={true}
>                     preferences={{position}}
>                     disabledSidePosition={
>                       position === 'bottom' && isForcedPosition
>                     }
>                     isRefresh={isRefresh}
>                     i18nStrings={{
>                       header: i18n(
>                         'i18nStrings.preferencesTitle',
>                         i18nStrings?.preferencesTitle
>                       ),
>                       confirm: i18n(
>                         'i18nStrings.preferencesConfirm',
>                         i18nStrings?.preferencesConfirm
>                       ),
>                       cancel: i18n(
>                         'i18nStrings.preferencesCancel',
>                         i18nStrings?.preferencesCancel
>                       ),
>                       positionLabel: i18n(
>                         'i18nStrings.preferencesPositionLabel',
>                         i18nStrings?.preferencesPositionLabel
>                       ),
>                       positionDescription: i18n(
>                         'i18nStrings.preferencesPositionDescription',
>                         i18nStrings?.preferencesPositionDescription
>                       ),
>                       positionBottom: i18n(
>                         'i18nStrings.preferencesPositionBottom',
>                         i18nStrings?.preferencesPositionBottom
>                       ),
>                       positionSide: i18n(
>                         'i18nStrings.preferencesPositionSide',
>                         i18nStrings?.preferencesPositionSide
>                       )
>                     }}
>                     onConfirm={preferences => {
>                       onPreferencesChange({...preferences})
>                       setPreferencesOpen(false)
>                     }}
>                     onDismiss={() => {
>                       setPreferencesOpen(false)
>                     }}
>                   />
>                 )}
>               </>
>             )}
>           </Transition>
>         )
>       }
>     )
diff -r src/components/split-panel/widget.jsx ../cloudcomp/lib/components/split-panel/widget.jsx
1c1
< import {forwardRef} from 'react'
---
> import {forwardRef, memo} from 'react'
6,14c6,16
< const createWidgetizedSplitPanel = SplitPanelLoader => {
<   return forwardRef((props, ref) => {
<     const isRefresh = useVisualRefresh()
<     if (isRefresh && getGlobalFlag('appLayoutWidget') && SplitPanelLoader) {
<       return <SplitPanelLoader ref={ref} {...props} />
<     }
<     return <SplitPanelImplementation ref={ref} {...props} />
<   })
< }
---
> const createWidgetizedSplitPanel = memo(SplitPanelLoader => {
>   return memo(
>     forwardRef((props, ref) => {
>       const isRefresh = useVisualRefresh()
>       if (isRefresh && getGlobalFlag('appLayoutWidget') && SplitPanelLoader) {
>         return <SplitPanelLoader ref={ref} {...props} />
>       }
>       return <SplitPanelImplementation ref={ref} {...props} />
>     })
>   )
> })
diff -r src/components/status-indicator/internal.jsx ../cloudcomp/lib/components/status-indicator/internal.jsx
8c8
< const typeToIcon = size => ({
---
> const typeToIcon = memo(size => ({
17c17
< })
---
> }))
diff -r src/components/table/internal.jsx ../cloudcomp/lib/components/table/internal.jsx
485,522c485,539
<                         allItems.map((item, rowIndex) => {
<                           const isFirstRow = rowIndex === 0
<                           const isLastRow = rowIndex === allItems.length - 1
<                           const sharedCellProps = {
<                             isFirstRow,
<                             isLastRow,
<                             isVisualRefresh,
<                             isSelected: hasSelection && isItemSelected(item),
<                             isPrevSelected:
<                               hasSelection &&
<                               !isFirstRow &&
<                               isItemSelected(allItems[rowIndex - 1]),
<                             isNextSelected:
<                               hasSelection &&
<                               !isLastRow &&
<                               isItemSelected(allItems[rowIndex + 1]),
<                             isEvenRow: rowIndex % 2 === 0,
<                             hasFooter,
<                             stripedRows,
<                             stickyState,
<                             tableRole
<                           }
<                           const expandableItemProps =
<                             getExpandableItemProps(item)
<                           return (
<                             <tr
<                               key={getItemKey(trackBy, item, rowIndex)}
<                               className={clsx(
<                                 styles.row,
<                                 sharedCellProps.isSelected &&
<                                   styles['row-selected']
<                               )}
<                               onFocus={({currentTarget}) => {
<                                 if (
<                                   !currentTarget.contains(getMouseDownTarget())
<                                 ) {
<                                   stickyHeaderRef.current?.scrollToRow(
<                                     currentTarget
---
>                         memo(
>                           allItems.map((item, rowIndex) => {
>                             const isFirstRow = rowIndex === 0
>                             const isLastRow = rowIndex === allItems.length - 1
>                             const sharedCellProps = {
>                               isFirstRow,
>                               isLastRow,
>                               isVisualRefresh,
>                               isSelected: hasSelection && isItemSelected(item),
>                               isPrevSelected:
>                                 hasSelection &&
>                                 !isFirstRow &&
>                                 isItemSelected(allItems[rowIndex - 1]),
>                               isNextSelected:
>                                 hasSelection &&
>                                 !isLastRow &&
>                                 isItemSelected(allItems[rowIndex + 1]),
>                               isEvenRow: rowIndex % 2 === 0,
>                               hasFooter,
>                               stripedRows,
>                               stickyState,
>                               tableRole
>                             }
>                             const expandableItemProps =
>                               getExpandableItemProps(item)
>                             return (
>                               <tr
>                                 key={getItemKey(trackBy, item, rowIndex)}
>                                 className={clsx(
>                                   styles.row,
>                                   sharedCellProps.isSelected &&
>                                     styles['row-selected']
>                                 )}
>                                 onFocus={({currentTarget}) => {
>                                   if (
>                                     !currentTarget.contains(
>                                       getMouseDownTarget()
>                                     )
>                                   ) {
>                                     stickyHeaderRef.current?.scrollToRow(
>                                       currentTarget
>                                     )
>                                   }
>                                 }}
>                                 {...focusMarkers.item}
>                                 onClick={
>                                   onRowClickHandler &&
>                                   onRowClickHandler.bind(null, rowIndex, item)
>                                 }
>                                 onContextMenu={
>                                   onRowContextMenuHandler &&
>                                   onRowContextMenuHandler.bind(
>                                     null,
>                                     rowIndex,
>                                     item
525,534c542,544
<                               }}
<                               {...focusMarkers.item}
<                               onClick={
<                                 onRowClickHandler &&
<                                 onRowClickHandler.bind(null, rowIndex, item)
<                               }
<                               onContextMenu={
<                                 onRowContextMenuHandler &&
<                                 onRowContextMenuHandler.bind(
<                                   null,
---
>                                 {...getTableRowRoleProps({
>                                   tableRole,
>                                   firstIndex,
536,601c546,570
<                                   item
<                                 )
<                               }
<                               {...getTableRowRoleProps({
<                                 tableRole,
<                                 firstIndex,
<                                 rowIndex,
<                                 ...expandableItemProps
<                               })}>
<                               {hasSelection && (
<                                 <TableTdElement
<                                   {...sharedCellProps}
<                                   className={clsx(styles['selection-control'])}
<                                   wrapLines={false}
<                                   hasSelection={true}
<                                   columnId={selectionColumnId}
<                                   colIndex={0}>
<                                   <SelectionControl
<                                     onFocusDown={moveFocusDown}
<                                     onFocusUp={moveFocusUp}
<                                     onShiftToggle={updateShiftToggle}
<                                     {...getItemSelectionProps(item)}
<                                   />
<                                 </TableTdElement>
<                               )}
<                               {visibleColumnDefinitions.map(
<                                 (column, colIndex) => {
<                                   const isEditing = cellEditing.checkEditing({
<                                     rowIndex,
<                                     colIndex
<                                   })
<                                   const successfulEdit =
<                                     cellEditing.checkLastSuccessfulEdit({
<                                       rowIndex,
<                                       colIndex
<                                     })
<                                   const isEditable =
<                                     !!column.editConfig &&
<                                     !cellEditing.isLoading
<                                   const expandableCellProps =
<                                     isExpandable && colIndex === 0
<                                       ? expandableItemProps
<                                       : void 0
<                                   return (
<                                     <TableBodyCell
<                                       key={getColumnKey(column, colIndex)}
<                                       {...sharedCellProps}
<                                       style={
<                                         resizableColumns
<                                           ? {}
<                                           : {
<                                               width: column.width,
<                                               minWidth: column.minWidth,
<                                               maxWidth: column.maxWidth
<                                             }
<                                       }
<                                       ariaLabels={ariaLabels}
<                                       column={column}
<                                       item={item}
<                                       wrapLines={wrapLines}
<                                       isEditable={isEditable}
<                                       isEditing={isEditing}
<                                       isRowHeader={column.isRowHeader}
<                                       successfulEdit={successfulEdit}
<                                       onEditStart={() =>
<                                         cellEditing.startEdit({
---
>                                   ...expandableItemProps
>                                 })}>
>                                 {hasSelection && (
>                                   <TableTdElement
>                                     {...sharedCellProps}
>                                     className={clsx(
>                                       styles['selection-control']
>                                     )}
>                                     wrapLines={false}
>                                     hasSelection={true}
>                                     columnId={selectionColumnId}
>                                     colIndex={0}>
>                                     <SelectionControl
>                                       onFocusDown={moveFocusDown}
>                                       onFocusUp={moveFocusUp}
>                                       onShiftToggle={updateShiftToggle}
>                                       {...getItemSelectionProps(item)}
>                                     />
>                                   </TableTdElement>
>                                 )}
>                                 {memo(
>                                   visibleColumnDefinitions.map(
>                                     (column, colIndex) => {
>                                       const isEditing =
>                                         cellEditing.checkEditing({
605,616c574,625
<                                       }
<                                       onEditEnd={editCancelled =>
<                                         cellEditing.completeEdit(
<                                           {rowIndex, colIndex},
<                                           editCancelled
<                                         )
<                                       }
<                                       submitEdit={cellEditing.submitEdit}
<                                       columnId={column.id ?? colIndex}
<                                       colIndex={colIndex + colIndexOffset}
<                                       {...expandableCellProps}
<                                     />
---
>                                       const successfulEdit =
>                                         cellEditing.checkLastSuccessfulEdit({
>                                           rowIndex,
>                                           colIndex
>                                         })
>                                       const isEditable =
>                                         !!column.editConfig &&
>                                         !cellEditing.isLoading
>                                       const expandableCellProps =
>                                         isExpandable && colIndex === 0
>                                           ? expandableItemProps
>                                           : void 0
>                                       return (
>                                         <TableBodyCell
>                                           key={getColumnKey(column, colIndex)}
>                                           {...sharedCellProps}
>                                           style={
>                                             resizableColumns
>                                               ? {}
>                                               : {
>                                                   width: column.width,
>                                                   minWidth: column.minWidth,
>                                                   maxWidth: column.maxWidth
>                                                 }
>                                           }
>                                           ariaLabels={ariaLabels}
>                                           column={column}
>                                           item={item}
>                                           wrapLines={wrapLines}
>                                           isEditable={isEditable}
>                                           isEditing={isEditing}
>                                           isRowHeader={column.isRowHeader}
>                                           successfulEdit={successfulEdit}
>                                           onEditStart={() =>
>                                             cellEditing.startEdit({
>                                               rowIndex,
>                                               colIndex
>                                             })
>                                           }
>                                           onEditEnd={editCancelled =>
>                                             cellEditing.completeEdit(
>                                               {rowIndex, colIndex},
>                                               editCancelled
>                                             )
>                                           }
>                                           submitEdit={cellEditing.submitEdit}
>                                           columnId={column.id ?? colIndex}
>                                           colIndex={colIndex + colIndexOffset}
>                                           {...expandableCellProps}
>                                         />
>                                       )
>                                     }
618,622c627,631
<                                 }
<                               )}
<                             </tr>
<                           )
<                         })
---
>                                 )}
>                               </tr>
>                             )
>                           })
>                         )
diff -r src/components/table/thead.jsx ../cloudcomp/lib/components/table/thead.jsx
111,142c111,144
<             {columnDefinitions.map((column, colIndex) => {
<               const columnId = getColumnKey(column, colIndex)
<               return (
<                 <TableHeaderCell
<                   key={columnId}
<                   style={getColumnStyles(sticky, columnId)}
<                   className={headerCellClass}
<                   tabIndex={sticky ? -1 : 0}
<                   focusedComponent={focusedComponent}
<                   column={column}
<                   activeSortingColumn={sortingColumn}
<                   sortingDescending={sortingDescending}
<                   sortingDisabled={sortingDisabled}
<                   wrapLines={wrapLines}
<                   hidden={hidden}
<                   colIndex={selectionType ? colIndex + 1 : colIndex}
<                   columnId={columnId}
<                   updateColumn={updateColumn}
<                   onResizeFinish={() => onResizeFinish(columnWidths)}
<                   resizableColumns={resizableColumns}
<                   onClick={detail =>
<                     fireNonCancelableEvent(onSortingChange, detail)
<                   }
<                   isEditable={!!column.editConfig}
<                   stickyState={stickyState}
<                   cellRef={node => setCell(sticky, columnId, node)}
<                   tableRole={tableRole}
<                   resizerRoleDescription={resizerRoleDescription}
<                   isExpandable={colIndex === 0 && isExpandable}
<                 />
<               )
<             })}
---
>             {memo(
>               columnDefinitions.map((column, colIndex) => {
>                 const columnId = getColumnKey(column, colIndex)
>                 return (
>                   <TableHeaderCell
>                     key={columnId}
>                     style={getColumnStyles(sticky, columnId)}
>                     className={headerCellClass}
>                     tabIndex={sticky ? -1 : 0}
>                     focusedComponent={focusedComponent}
>                     column={column}
>                     activeSortingColumn={sortingColumn}
>                     sortingDescending={sortingDescending}
>                     sortingDisabled={sortingDisabled}
>                     wrapLines={wrapLines}
>                     hidden={hidden}
>                     colIndex={selectionType ? colIndex + 1 : colIndex}
>                     columnId={columnId}
>                     updateColumn={updateColumn}
>                     onResizeFinish={() => onResizeFinish(columnWidths)}
>                     resizableColumns={resizableColumns}
>                     onClick={detail =>
>                       fireNonCancelableEvent(onSortingChange, detail)
>                     }
>                     isEditable={!!column.editConfig}
>                     stickyState={stickyState}
>                     cellRef={node => setCell(sticky, columnId, node)}
>                     tableRole={tableRole}
>                     resizerRoleDescription={resizerRoleDescription}
>                     isExpandable={colIndex === 0 && isExpandable}
>                   />
>                 )
>               })
>             )}
diff -r src/components/tabs/index.jsx ../cloudcomp/lib/components/tabs/index.jsx
47c47
<     const content = () => {
---
>     const content = memo(() => {
49c49
<       const renderContent = tab => {
---
>       const renderContent = memo(tab => {
72c72
<       }
---
>       })
86c86
<     }
---
>     })
diff -r src/components/tabs/tab-header-bar.jsx ../cloudcomp/lib/components/tabs/tab-header-bar.jsx
145c145
<     const renderTabHeader = tab => {
---
>     const renderTabHeader = memo(tab => {
261c261
<     }
---
>     })
diff -r src/components/tiles/internal.jsx ../cloudcomp/lib/components/tiles/internal.jsx
56,66c56,68
<               items.map((item, index) => (
<                 <Tile
<                   ref={index === tileRefIndex ? tileRef : void 0}
<                   key={item.value}
<                   item={item}
<                   selected={item.value === value}
<                   name={name || generatedName}
<                   breakpoint={breakpoint}
<                   onChange={onChange}
<                 />
<               ))}
---
>               memo(
>                 items.map((item, index) => (
>                   <Tile
>                     ref={index === tileRefIndex ? tileRef : void 0}
>                     key={item.value}
>                     item={item}
>                     selected={item.value === value}
>                     name={name || generatedName}
>                     breakpoint={breakpoint}
>                     onChange={onChange}
>                   />
>                 ))
>               )}
diff -r src/components/toggle/internal.jsx ../cloudcomp/lib/components/toggle/internal.jsx
11,79c11,81
<   forwardRef(
<     (
<       {
<         controlId,
<         checked,
<         name,
<         disabled,
<         children,
<         description,
<         ariaLabel,
<         ariaControls,
<         onFocus,
<         onBlur,
<         onChange,
<         __internalRootRef = null,
<         ...rest
<       },
<       ref
<     ) => {
<       const {ariaDescribedby, ariaLabelledby} = useFormFieldContext(rest)
<       const baseProps = getBaseProps(rest)
<       const checkboxRef = useRef(null)
<       useForwardFocus(ref, checkboxRef)
<       return (
<         <AbstractSwitch
<           {...baseProps}
<           className={clsx(styles.root, baseProps.className)}
<           controlClassName={clsx(styles['toggle-control'], {
<             [styles['toggle-control-checked']]: checked,
<             [styles['toggle-control-disabled']]: disabled
<           })}
<           outlineClassName={styles.outline}
<           controlId={controlId}
<           disabled={disabled}
<           label={children}
<           description={description}
<           descriptionBottomPadding={true}
<           ariaLabel={ariaLabel}
<           ariaLabelledby={ariaLabelledby}
<           ariaDescribedby={ariaDescribedby}
<           ariaControls={ariaControls}
<           nativeControl={nativeControlProps => (
<             <input
<               {...nativeControlProps}
<               ref={checkboxRef}
<               type='checkbox'
<               checked={checked}
<               name={name}
<               onFocus={() => fireNonCancelableEvent(onFocus)}
<               onBlur={() => fireNonCancelableEvent(onBlur)}
<               onChange={() => {}}
<             />
<           )}
<           onClick={() => {
<             checkboxRef.current?.focus()
<             fireNonCancelableEvent(onChange, {checked: !checked})
<           }}
<           styledControl={
<             <span
<               className={clsx(styles['toggle-handle'], {
<                 [styles['toggle-handle-checked']]: checked,
<                 [styles['toggle-handle-disabled']]: disabled
<               })}
<             />
<           }
<           __internalRootRef={__internalRootRef}
<         />
<       )
<     }
---
>   memo(
>     forwardRef(
>       (
>         {
>           controlId,
>           checked,
>           name,
>           disabled,
>           children,
>           description,
>           ariaLabel,
>           ariaControls,
>           onFocus,
>           onBlur,
>           onChange,
>           __internalRootRef = null,
>           ...rest
>         },
>         ref
>       ) => {
>         const {ariaDescribedby, ariaLabelledby} = useFormFieldContext(rest)
>         const baseProps = getBaseProps(rest)
>         const checkboxRef = useRef(null)
>         useForwardFocus(ref, checkboxRef)
>         return (
>           <AbstractSwitch
>             {...baseProps}
>             className={clsx(styles.root, baseProps.className)}
>             controlClassName={clsx(styles['toggle-control'], {
>               [styles['toggle-control-checked']]: checked,
>               [styles['toggle-control-disabled']]: disabled
>             })}
>             outlineClassName={styles.outline}
>             controlId={controlId}
>             disabled={disabled}
>             label={children}
>             description={description}
>             descriptionBottomPadding={true}
>             ariaLabel={ariaLabel}
>             ariaLabelledby={ariaLabelledby}
>             ariaDescribedby={ariaDescribedby}
>             ariaControls={ariaControls}
>             nativeControl={nativeControlProps => (
>               <input
>                 {...nativeControlProps}
>                 ref={checkboxRef}
>                 type='checkbox'
>                 checked={checked}
>                 name={name}
>                 onFocus={() => fireNonCancelableEvent(onFocus)}
>                 onBlur={() => fireNonCancelableEvent(onBlur)}
>                 onChange={() => {}}
>               />
>             )}
>             onClick={() => {
>               checkboxRef.current?.focus()
>               fireNonCancelableEvent(onChange, {checked: !checked})
>             }}
>             styledControl={
>               <span
>                 className={clsx(styles['toggle-handle'], {
>                   [styles['toggle-handle-checked']]: checked,
>                   [styles['toggle-handle-disabled']]: disabled
>                 })}
>               />
>             }
>             __internalRootRef={__internalRootRef}
>           />
>         )
>       }
>     )
diff -r src/components/token-group/internal.jsx ../cloudcomp/lib/components/token-group/internal.jsx
40c40
<           renderItem={(item, itemIndex) => (
---
>           renderItem={memo((item, itemIndex) => (
51c51
<           )}
---
>           ))}
diff -r src/components/top-navigation/internal.jsx ../cloudcomp/lib/components/top-navigation/internal.jsx
58c58
<     const content = isVirtual => {
---
>     const content = memo(isVirtual => {
157,158c157,200
<                   .map((utility, i) => {
<                     const hideText = !!responsiveState.hideUtilityText
---
>                   .map(
>                     memo((utility, i) => {
>                       const hideText = !!responsiveState.hideUtilityText
>                       const isLast =
>                         (isVirtual || !showMenuTrigger) &&
>                         i === utilities.length - 1
>                       const offsetRight =
>                         isLast && isLargeViewport
>                           ? 'xxl'
>                           : isLast
>                             ? 'l'
>                             : void 0
>                       return (
>                         <div
>                           key={i}
>                           className={clsx(
>                             styles['utility-wrapper'],
>                             styles[`utility-type-${utility.type}`],
>                             utility.type === 'button' &&
>                               styles[
>                                 `utility-type-button-${
>                                   utility.variant ?? 'link'
>                                 }`
>                               ],
>                             {
>                               [styles.narrow]: isNarrowViewport,
>                               [styles.medium]: isMediumViewport
>                             }
>                           )}
>                           data-utility-index={i}
>                           data-utility-hide={`${hideText}`}>
>                           <Utility
>                             hideText={hideText}
>                             definition={utility}
>                             offsetRight={offsetRight}
>                           />
>                         </div>
>                       )
>                     })
>                   )}
>               {isVirtual &&
>                 utilities.map(
>                   memo((utility, i) => {
>                     const hideText = !responsiveState.hideUtilityText
160,161c202
<                       (isVirtual || !showMenuTrigger) &&
<                       i === utilities.length - 1
---
>                       !showMenuTrigger && i === utilities.length - 1
190,221c231,232
<                   })}
<               {isVirtual &&
<                 utilities.map((utility, i) => {
<                   const hideText = !responsiveState.hideUtilityText
<                   const isLast = !showMenuTrigger && i === utilities.length - 1
<                   const offsetRight =
<                     isLast && isLargeViewport ? 'xxl' : isLast ? 'l' : void 0
<                   return (
<                     <div
<                       key={i}
<                       className={clsx(
<                         styles['utility-wrapper'],
<                         styles[`utility-type-${utility.type}`],
<                         utility.type === 'button' &&
<                           styles[
<                             `utility-type-button-${utility.variant ?? 'link'}`
<                           ],
<                         {
<                           [styles.narrow]: isNarrowViewport,
<                           [styles.medium]: isMediumViewport
<                         }
<                       )}
<                       data-utility-index={i}
<                       data-utility-hide={`${hideText}`}>
<                       <Utility
<                         hideText={hideText}
<                         definition={utility}
<                         offsetRight={offsetRight}
<                       />
<                     </div>
<                   )
<                 })}
---
>                   })
>                 )}
249c260
<     }
---
>     })
diff -r src/components/top-navigation/parts/overflow-menu/menu-item.jsx ../cloudcomp/lib/components/top-navigation/parts/overflow-menu/menu-item.jsx
134,146c134,148
<           {definition.items.map((item, index) => {
<             const isGroup = typeof item.items !== 'undefined'
<             return (
<               <li
<                 key={index}
<                 className={clsx(
<                   styles[`overflow-menu-list-item`],
<                   styles[`overflow-menu-list-item-dropdown-menu`]
<                 )}>
<                 {dropdownComponentFactory(item, isGroup, onItemClick)}
<               </li>
<             )
<           })}
---
>           {definition.items.map(
>             memo((item, index) => {
>               const isGroup = typeof item.items !== 'undefined'
>               return (
>                 <li
>                   key={index}
>                   className={clsx(
>                     styles[`overflow-menu-list-item`],
>                     styles[`overflow-menu-list-item-dropdown-menu`]
>                   )}>
>                   {dropdownComponentFactory(item, isGroup, onItemClick)}
>                 </li>
>               )
>             })
>           )}
152c154
< const utilityComponentFactory = (utility, index, ref) => {
---
> const utilityComponentFactory = memo((utility, index, ref) => {
233c235
< }
---
> })
235c237
< const dropdownComponentFactory = (item, expandable, onItemClick) => {
---
> const dropdownComponentFactory = memo((item, expandable, onItemClick) => {
275c277
< }
---
> })
diff -r src/components/top-navigation/parts/overflow-menu/views/submenu.jsx ../cloudcomp/lib/components/top-navigation/parts/overflow-menu/views/submenu.jsx
42,47c42,54
<           {definition.items.map((item, index) => (
<             <SubmenuItem
<               key={index}
<               {...item}
<               onClick={(event, item2) => {
<                 if (item2.to && isPlainLeftClick(event)) {
---
>           {definition.items.map(
>             memo((item, index) => (
>               <SubmenuItem
>                 key={index}
>                 {...item}
>                 onClick={(event, item2) => {
>                   if (item2.to && isPlainLeftClick(event)) {
>                     fireCancelableEvent(
>                       definition.onItemFollow,
>                       {id: item2.id, to: item2.to, external: item2.external},
>                       event
>                     )
>                   }
49c56
<                     definition.onItemFollow,
---
>                     definition.onItemClick,
53,62c60,64
<                 }
<                 fireCancelableEvent(
<                   definition.onItemClick,
<                   {id: item2.id, to: item2.to, external: item2.external},
<                   event
<                 )
<                 onClose?.()
<               }}
<             />
<           ))}
---
>                   onClose?.()
>                 }}
>               />
>             ))
>           )}
diff -r src/components/top-navigation/parts/overflow-menu/views/utilities.jsx ../cloudcomp/lib/components/top-navigation/parts/overflow-menu/views/utilities.jsx
25,33c25,35
<           {items.map((utility, index) => (
<             <UtilityMenuItem
<               key={index}
<               index={index}
<               ref={index === focusIndex ? ref : void 0}
<               onClose={onClose}
<               {...utility}
<             />
<           ))}
---
>           {items.map(
>             memo((utility, index) => (
>               <UtilityMenuItem
>                 key={index}
>                 index={index}
>                 ref={index === focusIndex ? ref : void 0}
>                 onClose={onClose}
>                 {...utility}
>               />
>             ))
>           )}
